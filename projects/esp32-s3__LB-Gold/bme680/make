#!/usr/bin/env python3
"""
ESP32-S3 BME680 Build System
Python-based build script that replaces Makefile functionality.

Usage:
    ./make build       - Compile the sketch (interactive sketch selection)
    ./make compile     - Compile with verbose output
    ./make progress    - Compile with progress bar
    ./make upload      - Upload to ESP32-S3
    ./make monitor     - Open serial monitor
    ./make clean       - Clean build artifacts
    ./make all         - Compile and upload
    ./make help        - Show this help message

Sketch Selection:
    ./make build                    - Interactive selection menu
    SKETCH=bme680 ./make build      - Use full version
    SKETCH=bme680-simplified ./make build  - Use simplified version
"""

import sys
import os
import subprocess
import shutil
import re
import time
import threading
from pathlib import Path
from typing import Optional, List, Dict, Tuple
from enum import Enum

# Add shared-python directory to sys.path
_script_dir = Path(__file__).parent.resolve()
_shared_python_dir = _script_dir.parent.parent.parent / "___shared" / "shared-python"

if str(_shared_python_dir) not in sys.path:
    sys.path.insert(0, str(_shared_python_dir))

# Import from local_imports
from local_imports import (  # type: ignore
    write_header,
    write_header_fat,
    error,
    warning,
    info,
    success,
    action,
    select,
    confirm,
    HAS_PROMPT_TOOLKIT,
)

# ============================================================================
# CONFIGURATION
# ============================================================================

PROJECT_ROOT = Path("D:/_dev/_projects/dev-boards")
FQBN = "esp32:esp32:esp32s3"
SKETCH_DIR = PROJECT_ROOT / "projects/esp32-s3__LB-Gold/bme680"
BUILD_PATH = SKETCH_DIR / "build"
LIBRARY_PATH = PROJECT_ROOT / "_libs/esp32-s3"
ARDUINO_CLI = PROJECT_ROOT / "Arduino/arduino-cli.exe"
PORT = "COM9"
BAUDRATE = 115200
SKETCH_ACTIVE = "bme680.ino"

# Sketch definitions
SKETCHES = [
    {
        "name": "bme680",
        "display": "bme680.ino - Full version (with calculations)",
        "description": "Includes heatsoak and IAQ calculations on ESP32",
    },
    {
        "name": "bme680-simplified",
        "display": "bme680-simplified.ino - Simplified (raw data only)",
        "description": "Publishes raw sensor data only, calculations done on RPi",
    },
]


# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def find_available_sketches() -> List[Dict]:
    """Find all available .ino files in the sketch directory."""
    available = []
    for sketch_info in SKETCHES:
        sketch_file = SKETCH_DIR / f"{sketch_info['name']}.ino"
        if sketch_file.exists():
            available.append(sketch_info)
    return available


def select_sketch_interactive() -> Optional[str]:
    """Show interactive menu and return selected sketch name."""
    available_sketches = find_available_sketches()
    
    if not available_sketches:
        error("No sketch files found!")
        return None
    
    if not HAS_PROMPT_TOOLKIT:
        warning("prompt_toolkit not available, using default sketch")
        return available_sketches[0]["name"]
    
    # Show header
    write_header("ESP32-S3 BME680 - Sketch Selection")
    print()
    
    # Create choices list
    choices = [sketch["display"] for sketch in available_sketches]
    
    # Show selection menu
    selected_display = select(
        "Select sketch to compile:",
        choices,
        pointer=" »",
    )
    
    if not selected_display:
        error("No sketch selected")
        return None
    
    # Find the sketch name from the selected display
    for sketch in available_sketches:
        if sketch["display"] == selected_display:
            return sketch["name"]
    
    return None


def get_sketch_name() -> Optional[str]:
    """Get sketch name from environment variable or interactive selection."""
    # Check if SKETCH environment variable is set
    sketch_env = os.environ.get("SKETCH")
    if sketch_env:
        return sketch_env
    
    # Otherwise, use interactive selection
    return select_sketch_interactive()


def prepare_sketch(sketch_name: str) -> bool:
    """Prepare sketch by copying selected sketch to active sketch file."""
    if not sketch_name:
        error("No sketch name provided")
        return False
    
    sketch_file = SKETCH_DIR / f"{sketch_name}.ino"
    active_file = SKETCH_DIR / SKETCH_ACTIVE
    
    if not sketch_file.exists():
        error(f"Sketch file not found: {sketch_file.name}")
        info("Available sketches:")
        for ino_file in SKETCH_DIR.glob("*.ino"):
            info(f"  - {ino_file.name}")
        return False
    
    # If selected sketch is different from active, copy it
    if sketch_file.name != SKETCH_ACTIVE:
        action(f"Switching sketch: {SKETCH_ACTIVE} → {sketch_file.name}")
        shutil.copy2(sketch_file, active_file)
        success(f"Sketch switched to {sketch_file.name}")
    else:
        success(f"Using sketch: {sketch_file.name}")
    
    return True


def run_arduino_cli(args: List[str], capture_output: bool = False) -> subprocess.CompletedProcess:
    """Run Arduino CLI command."""
    cmd = [str(ARDUINO_CLI)] + args
    try:
        if capture_output:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                check=False,
            )
        else:
            result = subprocess.run(cmd, check=False)
        return result
    except FileNotFoundError:
        error(f"Arduino CLI not found at: {ARDUINO_CLI}")
        sys.exit(1)


# ============================================================================
# BUILD COMMANDS
# ============================================================================

def cmd_help():
    """Show help message."""
    write_header("ESP32-S3 BME680 Sensor - Build Targets")
    print()
    info("Commands:")
    print("  ./make build       - Compile the sketch (interactive sketch selection)")
    print("  ./make compile     - Compile with verbose output")
    print("  ./make progress    - Compile with progress bar")
    print("  ./make upload      - Upload to ESP32-S3")
    print("  ./make monitor     - Open serial monitor")
    print("  ./make clean       - Clean build artifacts")
    print("  ./make all         - Compile and upload")
    print("  ./make help        - Show this help message")
    print()
    info("Sketch Selection:")
    print("  ./make build                          - Interactive selection menu")
    print("  SKETCH=bme680 ./make build            - Use full version")
    print("  SKETCH=bme680-simplified ./make build - Use simplified version")
    print()
    info("Configuration:")
    print(f"  FQBN: {FQBN}")
    print(f"  PORT: {PORT}")
    print(f"  Active Sketch: {SKETCH_ACTIVE}")


def cmd_compile(verbose: bool = True):
    """Compile the sketch."""
    sketch_name = get_sketch_name()
    if not sketch_name:
        return 1
    
    if not prepare_sketch(sketch_name):
        return 1
    
    write_header_fat("Compiling")
    print()
    action(f"Compiling {SKETCH_ACTIVE} ({sketch_name})...")
    print()
    
    args = [
        "compile",
        "--fqbn", FQBN,
        "--libraries", str(LIBRARY_PATH),
        "--build-path", str(BUILD_PATH),
    ]
    
    if verbose:
        args.append("--verbose")
    
    args.append(str(SKETCH_DIR))
    
    result = run_arduino_cli(args)
    
    if result.returncode == 0:
        print()
        success("Compilation successful!")
        return 0
    else:
        print()
        error("Compilation failed!")
        return 1


class CompileStage(Enum):
    """Compilation stages."""
    INITIALIZING = "Initializing"
    COMPILING = "Compiling"
    LINKING = "Linking"
    GENERATING = "Generating"
    COMPLETE = "Complete"


class ProgressMonitor:
    """Monitor Arduino CLI compilation progress."""
    
    def __init__(self):
        self.stage = CompileStage.INITIALIZING
        self.current_file = ""
        self.files_compiled = 0
        self.total_files = 0
        self.seen_files = set()  # Track unique files to count total
        self.errors = []
        self.lock = threading.Lock()
        self.start_time = time.time()
        self.last_update = time.time()
        
    def update_from_line(self, line: str):
        """Update progress from Arduino CLI output line."""
        with self.lock:
            self.last_update = time.time()
            line_lower = line.lower()
            
            # Detect compilation stage
            # Look for "Compiling" followed by file path
            if "compiling" in line_lower:
                # Check if it's actually compiling a source file
                if any(ext in line for ext in [".cpp", ".c", ".ino", ".S", ".hpp", ".h"]):
                    self.stage = CompileStage.COMPILING
                    # Extract filename - try multiple patterns
                    match = re.search(r'compiling\s+([^\s]+\.(cpp|c|ino|S|hpp|h))', line_lower)
                    if not match:
                        match = re.search(r'([^\s/\\]+\.(cpp|c|ino|S|hpp|h))', line)
                    if match:
                        file_path = match.group(1)
                        file_name = Path(file_path).name
                        self.current_file = file_name
                        
                        # Track unique files to estimate total
                        if file_path not in self.seen_files:
                            self.seen_files.add(file_path)
                            self.total_files = len(self.seen_files)
                
                # Count when compilation completes
                if "compiled" in line_lower or ".o" in line:
                    self.files_compiled += 1
            elif "linking" in line_lower or "link" in line_lower:
                self.stage = CompileStage.LINKING
                self.current_file = ""
            elif any(word in line_lower for word in ["generating", "creating", "building", ".bin", ".elf"]):
                if self.stage != CompileStage.LINKING:  # Only move to generating after linking
                    self.stage = CompileStage.GENERATING
                self.current_file = ""
            elif "error" in line_lower or "fatal" in line_lower:
                self.errors.append(line.strip())
    
    def get_progress(self) -> Tuple[CompileStage, str, float]:
        """Get current progress information."""
        with self.lock:
            elapsed = time.time() - self.start_time
            
            # Calculate percentage based on stage
            if self.stage == CompileStage.INITIALIZING:
                # Initializing: 0-5%
                percent = min(5, elapsed * 2)
            elif self.stage == CompileStage.COMPILING:
                # Compiling: 5-65%
                if self.total_files > 0:
                    # Use actual file count if we have it
                    file_progress = min(self.files_compiled / max(self.total_files, 1), 1.0)
                    percent = 5 + (file_progress * 60)
                else:
                    # Time-based estimate if we don't know total files yet
                    percent = 5 + min(60, elapsed * 2)
            elif self.stage == CompileStage.LINKING:
                # Linking: 65-90%
                percent = 65 + min(25, elapsed * 3)
            elif self.stage == CompileStage.GENERATING:
                # Generating: 90-99%
                percent = 90 + min(9, elapsed * 5)
            elif self.stage == CompileStage.COMPLETE:
                percent = 100
            else:
                percent = 0
            
            return self.stage, self.current_file, min(100, percent)


def print_progress_bar(percent: float, width: int = 40, stage: str = "", current_file: str = ""):
    """Print a progress bar with stage and file information."""
    filled = int(width * percent / 100)
    empty = width - filled
    
    # Build progress bar
    bar = "[" + "=" * filled + " " * empty + "]"
    
    # Build status line
    status_parts = []
    if stage:
        status_parts.append(stage)
    if current_file:
        status_parts.append(f"({current_file})")
    status = " - ".join(status_parts) if status_parts else ""
    
    # Clear line and print progress bar (works better on Windows)
    # Use ANSI escape codes to clear to end of line
    print(f"\r\033[K{bar} {percent:5.1f}% {status}", end="", flush=True)


def cmd_progress():
    """Compile with progress bar."""
    sketch_name = get_sketch_name()
    if not sketch_name:
        return 1
    
    if not prepare_sketch(sketch_name):
        return 1
    
    write_header_fat("Compiling with Progress")
    print()
    action(f"Compiling {SKETCH_ACTIVE} ({sketch_name})...")
    print()
    
    args = [
        "compile",
        "--fqbn", FQBN,
        "--libraries", str(LIBRARY_PATH),
        "--build-path", str(BUILD_PATH),
        # Don't use --verbose - it produces too much output
        # We'll parse the normal output instead
        str(SKETCH_DIR),
    ]
    
    # Create progress monitor
    monitor = ProgressMonitor()
    
    # Start Arduino CLI process
    cmd = [str(ARDUINO_CLI)] + args
    try:
        # Capture all output - use line buffering for real-time updates
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,  # Line buffered
            universal_newlines=True,
        )
    except FileNotFoundError:
        error(f"Arduino CLI not found at: {ARDUINO_CLI}")
        return 1
    
    # Monitor output in real-time - suppress all output, show only progress bar
    try:
        last_progress_update = 0
        print_progress_bar(0, width=40, stage="Initializing")
        
        # Read all output but don't print it
        all_output = []
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            
            if output:
                all_output.append(output)
                # Update monitor with line (but don't print it)
                monitor.update_from_line(output)
                
                # Update progress bar frequently (every 100ms)
                now = time.time()
                if now - last_progress_update >= 0.1:
                    stage, current_file, percent = monitor.get_progress()
                    print_progress_bar(
                        percent,
                        width=40,
                        stage=stage.value,
                        current_file=current_file[:25] if current_file else ""
                    )
                    last_progress_update = now
        
        # Wait for process to complete
        return_code = process.poll()
        
        # Final progress update
        stage, current_file, percent = monitor.get_progress()
        print_progress_bar(100, width=40, stage="Complete")
        
        print()  # New line after progress bar
        
        if return_code == 0:
            # Show summary if available
            print()
            success("Compilation successful!")
            return 0
        else:
            print()
            error("Compilation failed!")
            
            # Show compilation errors from captured output
            if all_output:
                print()
                error("Compilation output (errors):")
                # Look for error lines in the output
                error_lines = []
                for line in all_output:
                    line_lower = line.lower().strip()
                    if line_lower and any(keyword in line_lower for keyword in [
                        "error", "fatal", "undefined", "multiple definition", 
                        "has no member", "error during build", "exit status"
                    ]):
                        error_lines.append(line.strip())
                
                if error_lines:
                    for err in error_lines[:20]:  # Show first 20 error lines
                        print(f"  {err}")
                else:
                    # If no specific errors found, show last 30 lines of output
                    print("  Last output lines:")
                    for line in all_output[-30:]:
                        if line.strip():
                            print(f"  {line.strip()}")
            
            if monitor.errors:
                print()
                error("Additional errors detected:")
                for err in monitor.errors[:10]:  # Show first 10 errors
                    print(f"  {err}")
            
            return 1
            
    except KeyboardInterrupt:
        process.terminate()
        print()  # New line after progress bar
        error("Compilation cancelled by user")
        return 1


def cmd_upload():
    """Upload to ESP32-S3."""
    write_header_fat("Uploading")
    print()
    action(f"Uploading to ESP32-S3 on {PORT}...")
    print()
    
    args = [
        "upload",
        "-p", PORT,
        "--fqbn", FQBN,
        "--build-path", str(BUILD_PATH),
        str(SKETCH_DIR),
    ]
    
    result = run_arduino_cli(args)
    
    if result.returncode == 0:
        print()
        success("Upload successful!")
        return 0
    else:
        print()
        error("Upload failed!")
        return 1


def cmd_monitor():
    """Open serial monitor."""
    action(f"Opening serial monitor on {PORT} at {BAUDRATE} baud...")
    args = [
        "monitor",
        "-p", PORT,
        "--config", f"baudrate={BAUDRATE}",
    ]
    
    # Monitor runs until user exits
    run_arduino_cli(args)


def cmd_clean():
    """Clean build artifacts."""
    write_header_fat("Cleaning")
    print()
    action("Cleaning build artifacts...")
    
    # Remove build directory
    if BUILD_PATH.exists():
        shutil.rmtree(BUILD_PATH)
    
    # Run Arduino CLI clean
    args = [
        "compile",
        "--fqbn", FQBN,
        "--clean",
        str(SKETCH_DIR),
    ]
    
    run_arduino_cli(args)
    success("Clean complete!")


def cmd_all():
    """Compile and upload in one step."""
    if cmd_compile() == 0:
        print()
        if cmd_upload() == 0:
            print()
            success("Build and upload complete!")
            return 0
    
    return 1


def cmd_sketch_status():
    """Show current sketch status."""
    write_header("Sketch Status")
    print()
    
    active_file = SKETCH_DIR / SKETCH_ACTIVE
    info(f"Active Sketch: {SKETCH_ACTIVE}")
    
    if active_file.exists():
        success("Active file exists: ✓")
        # Try to detect source sketch from file content
        try:
            first_line = active_file.read_text().split('\n')[0]
            if "simplified" in first_line.lower():
                info("Source: bme680-simplified.ino")
            else:
                info("Source: bme680.ino")
        except Exception:
            pass
    else:
        warning("Active file exists: ✗")
    
    print()
    info("Available sketches:")
    for ino_file in sorted(SKETCH_DIR.glob("*.ino")):
        if ino_file.name == SKETCH_ACTIVE:
            print(f"  ✓ {ino_file.name} (active)")
        else:
            print(f"    {ino_file.name}")


# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        cmd_help()
        return 0
    
    command = sys.argv[1].lower()
    
    commands = {
        "help": cmd_help,
        "build": lambda: cmd_compile(),
        "compile": lambda: cmd_compile(),
        "progress": cmd_progress,
        "upload": cmd_upload,
        "monitor": cmd_monitor,
        "clean": cmd_clean,
        "all": cmd_all,
        "sketch-status": cmd_sketch_status,
    }
    
    if command in commands:
        try:
            return commands[command]() or 0
        except KeyboardInterrupt:
            print()
            error("Operation cancelled by user")
            return 1
        except Exception as e:
            error(f"Error: {e}")
            return 1
    else:
        error(f"Unknown command: {command}")
        print()
        cmd_help()
        return 1


if __name__ == "__main__":
    sys.exit(main())

