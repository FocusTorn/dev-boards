#!/usr/bin/env python3
"""
ESP32-S3 SHT21 Sensor Build System
Python-based build script that replaces Makefile functionality.

Usage:
    python pmake              - Interactive action selection menu
    python pmake build        - Compile the sketch (alias for compile)
    python pmake compile      - Compile with verbose output
    python pmake progress     - Compile with progress bar
    python pmake upload       - Upload to ESP32-S3
    python pmake monitor      - Open serial monitor
    python pmake clean        - Clean build artifacts
    python pmake all          - Compile and upload
    python pmake help         - Show this help message
"""

# IMPORTS ------------------->> 

import sys
import os
import subprocess
import shutil
import re
import time
import threading
from pathlib import Path
from typing import Optional, List, Dict, Tuple
from enum import Enum

# Add shared-python directory to sys.path
_script_dir = Path(__file__).parent.resolve()
_shared_python_dir = _script_dir.parent.parent.parent / "___shared" / "shared-python"

if str(_shared_python_dir) not in sys.path:
    sys.path.insert(0, str(_shared_python_dir))

# Import from local_imports
from local_imports import (  # type: ignore
    write_header,
    write_header_fat,
    write_boxed_header,
    error,
    warning,
    info,
    success,
    action,
    select,
    confirm,
    HAS_PROMPT_TOOLKIT,
)

#---------------------------------------------------------<<

# CONFIGURATION ------------->> 

PROJECT_ROOT = Path("D:/_dev/_Projects/dev-boards")
FQBN = "esp32:esp32:esp32s3"
SKETCH_DIR = PROJECT_ROOT / "_projects/esp32-s3__LB-Gold/sht21-solo"
BUILD_PATH = SKETCH_DIR / "build"
LIBRARY_PATH = PROJECT_ROOT / "_libs/esp32-s3"
ARDUINO_CLI = PROJECT_ROOT / "Arduino/arduino-cli.exe"
PORT = "COM9"
BAUDRATE = 115200
SKETCH_NAME = "sht21-solo.ino"

#---------------------------------------------------------<<

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def verify_sketch() -> bool: #>
    """Verify that the sketch file exists."""
    sketch_file = SKETCH_DIR / SKETCH_NAME
    if not sketch_file.exists():
        error(f"Sketch file not found: {SKETCH_NAME}")
        info("Available sketches:")
        for ino_file in SKETCH_DIR.glob("*.ino"):
            info(f"  - {ino_file.name}")
        return False
    return True

 #<

def run_arduino_cli(args: List[str], capture_output: bool = False) -> subprocess.CompletedProcess: #>
    """Run Arduino CLI command."""
    cmd = [str(ARDUINO_CLI)] + args
    try:
        if capture_output:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                check=False,
            )
        else:
            # Disable terminal line wrapping to prevent output from wrapping
            # ANSI escape code: \x1b[?7l = disable wrapping, \x1b[?7h = enable wrapping
            DISABLE_WRAP = '\x1b[?7l'
            ENABLE_WRAP = '\x1b[?7h'
            
            # Get the original stream (bypass IndentedOutput wrapper for escape codes)
            # Escape codes should go directly to the terminal, not through indentation
            original_stdout = sys.stdout.original_stream if hasattr(sys.stdout, 'original_stream') else sys.stdout
            original_stderr = sys.stderr.original_stream if hasattr(sys.stderr, 'original_stream') else sys.stderr
            
            # Disable wrapping before starting process (write to original stream)
            original_stdout.write(DISABLE_WRAP)
            original_stdout.flush()
            original_stderr.write(DISABLE_WRAP)
            original_stderr.flush()
            
            try:
                # Use Popen to capture output and write through sys.stdout/stderr
                # This ensures output goes through IndentedOutput wrapper for proper indentation
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    bufsize=1,  # Line buffered
                    universal_newlines=True,
                )
                
                # Read from both stdout and stderr in real-time
                output_lines = []
                error_lines = []
                
                # Use threads to read from both streams simultaneously
                def read_stdout():
                    for line in iter(process.stdout.readline, ''):
                        if line:
                            sys.stdout.write(line)
                            sys.stdout.flush()
                            output_lines.append(line)
                    process.stdout.close()
                
                def read_stderr():
                    for line in iter(process.stderr.readline, ''):
                        if line:
                            sys.stderr.write(line)
                            sys.stderr.flush()
                            error_lines.append(line)
                    process.stderr.close()
                
                # Start threads to read both streams
                stdout_thread = threading.Thread(target=read_stdout, daemon=True)
                stderr_thread = threading.Thread(target=read_stderr, daemon=True)
                
                stdout_thread.start()
                stderr_thread.start()
                
                # Wait for process to complete
                return_code = process.wait()
                
                # Wait for threads to finish reading
                stdout_thread.join()
                stderr_thread.join()
                
                # Create CompletedProcess object
                result = subprocess.CompletedProcess(
                    cmd,
                    return_code,
                    stdout=''.join(output_lines),
                    stderr=''.join(error_lines),
                )
            finally:
                # Always re-enable wrapping, even if an error occurs (write to original stream)
                original_stdout.write(ENABLE_WRAP)
                original_stdout.flush()
                original_stderr.write(ENABLE_WRAP)
                original_stderr.flush()
        return result
    except FileNotFoundError:
        error(f"Arduino CLI not found at: {ARDUINO_CLI}")
        sys.exit(1)

 #<

# ============================================================================
# BUILD COMMANDS
# ============================================================================

def cmd_help(): #>
    """Show help message."""
    write_header("ESP32-S3 SHT21 Sensor - Build Targets")
    print()
    info("Commands:")
    print("  python pmake              - Interactive action selection menu")
    print("  python pmake build        - Compile the sketch (alias for compile)")
    print("  python pmake compile      - Compile with verbose output")
    print("  python pmake progress     - Compile with progress bar")
    print("  python pmake upload       - Upload to ESP32-S3")
    print("  python pmake monitor      - Open serial monitor")
    print("  python pmake clean        - Clean build artifacts")
    print("  python pmake all          - Compile and upload")
    print("  python pmake help         - Show this help message")
    print()
    info("Configuration:")
    print(f"  FQBN: {FQBN}")
    print(f"  PORT: {PORT}")
    print(f"  Sketch: {SKETCH_NAME}")

 #<

def select_action_interactive() -> Optional[str]: #>
    """Show interactive menu to select action."""
    if not HAS_PROMPT_TOOLKIT:
        warning("prompt_toolkit not available, showing help instead")
        cmd_help()
        return None
    
    # Get folder name for title (e.g., "sht21-solo" -> "SHT21 Solo")
    folder_name = SKETCH_DIR.name
    # Convert folder name to title: "sht21-solo" -> "SHT21 Solo - Action Selection"
    title_parts = folder_name.replace("-", " ").replace("_", " ").split()
    title = " ".join(word.capitalize() for word in title_parts) + " - Action Selection"
    
    write_boxed_header(title)
    print()
    
    actions = [
        ("Build", "Compile the sketch (alias for compile)"),
        ("Compile", "Compile with verbose output"),
        ("Progress", "Compile with progress bar"),
        ("Upload", "Upload to ESP32-S3 (no compile)"),
        ("Monitor", "Open serial monitor"),
        ("Clean", " Clean build artifacts"),
        ("All", "Compile and upload in one step"),
        ("Help", "Show help message"),
    ]
    
    choices = [f"{action[0]}" for action in actions]
    
    def get_toolbar(current_index, choices):
        """Toolbar function that receives current selection index and updates dynamically."""
        # Get the description from the actions list using the current index
        description = actions[current_index][1]
        return description
    
    
    selected = select(
        "Select action to perform:",
        choices,
        # pointer=" »",
        bottom_toolbar=get_toolbar

    )
    
    if not selected:
        error("No action selected")
        return None
    
    # Extract action name from selection
    # action_name = selected.split(" - ")[0]
    
    return selected

 #<

def cmd_compile(verbose: bool = True): #>
    """Compile the sketch."""
    if not verify_sketch():
        return 1
    
    print("")
    
    with write_header_fat("Compiling"):
        print(action(f"Compiling {SKETCH_NAME}..."))
        
        print("")
        
        args = [
            "compile",
            "--fqbn", FQBN,
            "--libraries", str(LIBRARY_PATH),
            "--build-path", str(BUILD_PATH),
        ]
        
        if verbose:
            args.append("--verbose")
        
        args.append(str(SKETCH_DIR))
        
        result = run_arduino_cli(args)
        
        if result.returncode == 0:
            print()
            success("Compilation successful!")
            return 0
        else:
            print()
            error("Compilation failed!")
            return 1

 #<

class CompileStage(Enum): #>
    """Compilation stages."""
    INITIALIZING = "Initializing"
    COMPILING = "Compiling"
    LINKING = "Linking"
    GENERATING = "Generating"
    COMPLETE = "Complete"

 #<

class ProgressMonitor: #>
    """Monitor Arduino CLI compilation progress."""
    
    def __init__(self, log_file=None):
        self.log_file = log_file  # Optional log file handle
        self.last_logged_percent = -1  # Track last logged percent for markers
        self.stage = CompileStage.INITIALIZING
        self.current_file = ""
        self.files_compiled = 0
        self.total_files = 0
        self.compile_lines = []  # Track all "Compiling file.cpp" lines seen
        self.compiled_lines = []  # Track all ".cpp.o" or "Compiled" lines seen
        
        # Library tracking
        self.libraries_seen = set()  # Track unique library names seen
        self.libraries_compiled = set()  # Track libraries that have been compiled
        self.current_library = ""  # Current library being compiled
        self.library_files = {}  # Track files per library: {library_name: [file1, file2, ...]}
        self.total_libraries = 0  # Estimated or actual total libraries
        
        self.errors = []
        self.summary_lines = []  # Track final summary lines (memory usage, libraries) - original format with colors
        self.in_summary_section = False  # Track if we're in the summary section
        self.lock = threading.Lock()
        self.start_time = time.time()
        self.last_update = time.time()
        self.last_percent = 0
        
        # Sub-stage tracking
        self.detecting_libraries = False  # "Detecting libraries used..."
        self.generating_prototypes = False  # "Generating function prototypes..."
        self.compiling_libraries = False  # "Compiling libraries..."
        self.compiling_core = False  # "Compiling core..."
        self.compiling_sketch = False  # "Compiling sketch..."
        self.libraries_detected = False
        self.prototypes_generated = False
        
        # Stage start times
        self.compile_stage_start_time = None  # When compiling stage started
        self.link_stage_start_time = None  # When linking stage started
        self.generate_stage_start_time = None  # When generating stage started
        self.detect_libs_start_time = None
        self.gen_prototypes_start_time = None
        
        # Progress tracking
        self.avg_file_compile_time = 0.0  # Average time per file compilation
        self.file_compile_times = []  # Track compile times for better estimates
        self.total_files_discovered_time = None  # When we first discovered total_files
        self.last_time_based_percent = 5.0  # Last time-based estimate before discovering files
        
    def update_from_line(self, line: str):
        """Update progress from Arduino CLI output line."""
        with self.lock:
            self.last_update = time.time()
            line_lower = line.lower()
            line_stripped = line.strip()
            
            # Detect summary section start (when we see "Sketch uses", "Global variables", "Used library", or "Used platform")
            # Continue capturing until compilation completes
            if ("sketch uses" in line_lower or 
                "global variables use" in line_lower or 
                "used library" in line_lower or 
                "used platform" in line_lower):
                self.in_summary_section = True
            
            # If we're in summary section, capture all lines (preserving original format/colors)
            # This includes: memory usage, library list, platform info, etc.
            # Continue capturing until we see something that's clearly not part of the summary
            if self.in_summary_section:
                # Only stop capturing if we see a new compilation or error that's clearly not summary
                # For now, continue capturing all lines once we're in summary mode
                # Store original line (with colors/formatting), only strip trailing whitespace
                # Capture all lines including empty ones (they're part of the formatting)
                self.summary_lines.append(line.rstrip())
            
            # Skip empty lines for progress tracking (but still capture in summary if in summary section)
            if not line_stripped:
                return
            
            # Detect early sub-stages that happen during initialization/early compilation
            # Pattern 0a: "Detecting libraries used..."
            if "detecting libraries" in line_lower or "detecting library" in line_lower:
                self.detecting_libraries = True
                self.libraries_detected = False
                if self.detect_libs_start_time is None:
                    self.detect_libs_start_time = time.time()
                # If still initializing, this is a sign we're progressing
                if self.stage == CompileStage.INITIALIZING:
                    # Transition to compiling stage (library detection is part of prep work)
                    self.stage = CompileStage.COMPILING
                    if self.compile_stage_start_time is None:
                        self.compile_stage_start_time = time.time()
            
            # Pattern 0b: "Generating function prototypes..."
            elif "generating function prototypes" in line_lower or "generating prototypes" in line_lower:
                self.generating_prototypes = True
                self.prototypes_generated = False
                if self.gen_prototypes_start_time is None:
                    self.gen_prototypes_start_time = time.time()
                # Mark that libraries have been detected (prototypes come after)
                self.libraries_detected = True
                self.detecting_libraries = False
                # Ensure we're in compiling stage
                if self.stage != CompileStage.COMPILING:
                    self.stage = CompileStage.COMPILING
                    if self.compile_stage_start_time is None:
                        self.compile_stage_start_time = time.time()
            
            # Pattern 0c: Check if library detection is complete (when we see compilation starting)
            # This helps us know when to mark libraries_detected = True
            elif self.detecting_libraries and ("compiling" in line_lower or "xtensa-esp32s3-elf" in line):
                self.libraries_detected = True
                self.detecting_libraries = False
            
            # Pattern 0d: Check if prototypes are complete (when actual file compilation starts)
            elif self.generating_prototypes and ("xtensa-esp32s3-elf" in line or re.search(r'compiling\s+[^\s]+\.(cpp|c|ino|S)', line_lower, re.IGNORECASE)):
                self.prototypes_generated = True
                self.generating_prototypes = False
            
            # Detect compilation stage based on actual Arduino CLI output patterns
            # Based on Makefile approach: count compilation lines and compiled lines
            
            # Pattern 1: Compiler invocations - these indicate files being compiled
            # Match: "xtensa-esp32s3-elf-g++" or "xtensa-esp32s3-elf-gcc" with -c flag (compile flag)
            if ("xtensa-esp32s3-elf-g++" in line or "xtensa-esp32s3-elf-gcc" in line) and "-c" in line:
                if self.stage != CompileStage.COMPILING:
                    self.stage = CompileStage.COMPILING
                    if self.compile_stage_start_time is None:
                        self.compile_stage_start_time = time.time()
                # Try to extract filename from the command
                # Look for @file (response file) or direct file path
                file_match = re.search(r'@([^\s]+\.(cpp|c|ino|S))|([^\s/\\]+\.(cpp|c|ino|S))', line, re.IGNORECASE)
                if file_match:
                    file_path = file_match.group(1) or file_match.group(3)
                    if file_path:
                        file_name = Path(file_path).name
                        self.current_file = file_name
                        
                        # Try to determine which library this file belongs to from path
                        # Common patterns: libraries/LibraryName/src/file.cpp or libraries/LibraryName/file.cpp
                        lib_from_path = None
                        path_lower = str(file_path).lower()
                        if '/libraries/' in path_lower or '\\libraries\\' in path_lower:
                            # Extract library name from path
                            lib_match = re.search(r'libraries[/\\]([^/\\]+)', path_lower, re.IGNORECASE)
                            if lib_match:
                                lib_from_path = lib_match.group(1)
                        elif '/core/' in path_lower or '\\core\\' in path_lower:
                            lib_from_path = "_core_"  # Special marker for core files
                        
                        # Use current library if set, otherwise try to infer from path
                        active_lib = self.current_library if self.current_library else (lib_from_path if lib_from_path else None)
                        
                        # Count as a file to compile
                        if line_stripped not in self.compile_lines:
                            self.compile_lines.append(line_stripped)
                            self.total_files = len(self.compile_lines)
                            
                            # Track file per library if we know the library
                            if active_lib and active_lib != "_core_":
                                if active_lib not in self.library_files:
                                    self.library_files[active_lib] = []
                                if file_name not in self.library_files[active_lib]:
                                    self.library_files[active_lib].append(file_name)
                                # Update library count if we discovered a new library
                                if active_lib not in self.libraries_seen:
                                    self.libraries_seen.add(active_lib)
                                    self.total_libraries = len(self.libraries_seen)
            
            # Pattern 1b: "Compiling" lines with file extensions - also count as total files
            # Match: "Compiling file.cpp" or "Compiling path/to/file.c"
            elif re.search(r'compiling\s+[^\s]+\.(cpp|c|ino|S)', line_lower, re.IGNORECASE):
                compile_match = re.search(r'compiling\s+([^\s]+\.(cpp|c|ino|S))', line_lower, re.IGNORECASE)
                if compile_match:
                    file_path = compile_match.group(1)
                    file_name = Path(file_path).name
                    self.current_file = file_name
                    if self.stage != CompileStage.COMPILING:
                        self.stage = CompileStage.COMPILING
                        if self.compile_stage_start_time is None:
                            self.compile_stage_start_time = time.time()
                    
                    # Track this compilation line (like Makefile counts grep lines)
                    if line_stripped not in self.compile_lines:
                        self.compile_lines.append(line_stripped)
                        self.total_files = len(self.compile_lines)
            
            # Pattern 1c: "Compiling sketch..." or "Compiling library..." messages
            elif "compiling" in line_lower:
                if self.stage != CompileStage.COMPILING:
                    self.stage = CompileStage.COMPILING
                    if self.compile_stage_start_time is None:
                        self.compile_stage_start_time = time.time()
                if "compiling sketch" in line_lower:
                    # Mark current library as done if we were compiling libraries
                    if self.current_library and self.current_library.lower() != "libraries":
                        self.libraries_compiled.add(self.current_library)
                        self.current_library = ""
                    self.current_file = "sketch"
                    self.compiling_sketch = True
                    # Mark that prototypes are done (sketch compilation comes after)
                    self.prototypes_generated = True
                    self.generating_prototypes = False
                elif "compiling library" in line_lower or "compiling libraries" in line_lower:
                    # Extract library name: "Compiling library \"Wire\"" or "Compiling libraries..."
                    match = re.search(r'compiling libraries?[:\s]+"?([^"]+)"?', line_lower)
                    if match:
                        lib_name = match.group(1)
                        
                        # If we're switching to a new library, mark the previous one as compiled
                        if self.current_library and self.current_library != lib_name and self.current_library.lower() != "libraries":
                            self.libraries_compiled.add(self.current_library)
                        
                        self.current_file = lib_name
                        self.current_library = lib_name
                        # Track this library
                        if lib_name and lib_name.lower() != "libraries":
                            self.libraries_seen.add(lib_name)
                            self.total_libraries = len(self.libraries_seen)
                            # Initialize file list for this library if not exists
                            if lib_name not in self.library_files:
                                self.library_files[lib_name] = []
                    else:
                        # Generic "compiling libraries" - mark previous library as done if we had one
                        if self.current_library and self.current_library.lower() != "libraries":
                            self.libraries_compiled.add(self.current_library)
                        self.current_file = "libraries"
                        self.current_library = ""
                    self.compiling_libraries = True
                    # Mark that prototypes are done (library compilation comes after)
                    self.prototypes_generated = True
                    self.generating_prototypes = False
                elif "compiling core" in line_lower:
                    # Mark current library as done if we were compiling libraries
                    if self.current_library and self.current_library.lower() != "libraries":
                        self.libraries_compiled.add(self.current_library)
                        self.current_library = ""
                    self.current_file = "core"
                    self.compiling_core = True
                    # Mark that prototypes are done (core compilation comes after)
                    self.prototypes_generated = True
                    self.generating_prototypes = False
            
            # Pattern 2: Count compiled files - look for object file creation or archive operations
            # Match: ".cpp.o", ".c.o", "gcc-ar" (archive creation means files compiled), or "Compiled" messages
            if re.search(r'\.(cpp|c|ino|S)\.o|gcc-ar|compiled\s+[^\s]+\.(cpp|c|ino|S)', line_lower, re.IGNORECASE):
                # Found evidence of a file being compiled (object file created or archived)
                if line_stripped not in self.compiled_lines:
                    # Track compilation time for this file
                    file_compile_time = time.time() - self.last_update
                    if file_compile_time > 0:
                        self.file_compile_times.append(file_compile_time)
                        # Update average compile time (use last 10 files for moving average)
                        recent_times = self.file_compile_times[-10:]
                        self.avg_file_compile_time = sum(recent_times) / len(recent_times)
                    
                    self.compiled_lines.append(line_stripped)
                    self.files_compiled = len(self.compiled_lines)
                    # Cap at total_files if we know it
                    if self.total_files > 0 and self.files_compiled > self.total_files:
                        self.files_compiled = self.total_files
            
            # Pattern 2: "Linking everything together..."
            elif "linking everything together" in line_lower or ("linking" in line_lower and "together" in line_lower):
                # Mark any remaining library as compiled (all compilation is done)
                if self.current_library and self.current_library.lower() != "libraries":
                    self.libraries_compiled.add(self.current_library)
                    self.current_library = ""
                # Mark all seen libraries as compiled since we're linking
                self.libraries_compiled.update(self.libraries_seen)
                
                if self.stage != CompileStage.LINKING:
                    self.stage = CompileStage.LINKING
                    if self.link_stage_start_time is None:
                        self.link_stage_start_time = time.time()
                self.current_file = ""
            
            # Pattern 3: "Creating ESP32S3 image..." or esptool output
            elif "creating esp32" in line_lower or "creating image" in line_lower or ("esptool" in line_lower and "elf2image" in line_lower):
                if self.stage != CompileStage.GENERATING:
                    self.stage = CompileStage.GENERATING
                    if self.generate_stage_start_time is None:
                        self.generate_stage_start_time = time.time()
                self.current_file = ""
            
            # Pattern 4: Final summary lines (memory usage, etc.) - already captured above
            if "sketch uses" in line_lower or "global variables use" in line_lower:
                self.stage = CompileStage.COMPLETE
                self.current_file = ""
            
            # Pattern 5: Error detection
            elif "error" in line_lower or "fatal" in line_lower:
                self.errors.append(line.strip())
            
            # Pattern 6: If we see compiler commands and we're still initializing, move to compiling
            elif ("xtensa-esp32s3-elf-g++" in line or "xtensa-esp32s3-elf-gcc" in line) and self.stage == CompileStage.INITIALIZING:
                self.stage = CompileStage.COMPILING
                if self.compile_stage_start_time is None:
                    self.compile_stage_start_time = time.time()
                self.files_compiled += 1
            
            # Pattern 7: Aggressive transition from INITIALIZING - if we see any meaningful output
            # after a few seconds, assume we're compiling (in case patterns above didn't match)
            # This ensures we don't get stuck at 5% for the entire compilation
            if self.stage == CompileStage.INITIALIZING and line_stripped:
                elapsed_since_start = time.time() - self.start_time
                # After 3 seconds, if we see any meaningful output (not just setup messages),
                # transition to compiling
                if elapsed_since_start > 3.0:
                    # Skip common initialization messages
                    init_messages = ["using", "fqbn", "multiple", "board", "platform", "package"]
                    line_lower_start = line_lower[:20]  # Check first 20 chars
                    if not any(msg in line_lower_start for msg in init_messages):
                        # This looks like compilation output, transition to compiling
                        self.stage = CompileStage.COMPILING
                        if self.compile_stage_start_time is None:
                            self.compile_stage_start_time = time.time()
    
    def get_progress(self) -> Tuple[CompileStage, str, float]:
        """Get current progress information with dynamic, granular calculation."""
        with self.lock:
            elapsed = time.time() - self.start_time
            compile_elapsed = 0
            if self.compile_stage_start_time:
                compile_elapsed = time.time() - self.compile_stage_start_time
            
            # Calculate percentage based on stage with more granular, dynamic calculations
            percent = self.last_percent
            
            if self.stage == CompileStage.INITIALIZING:
                # Pre-allocated sub-stage ranges:
                #   0-3%:   Basic initialization
                #   3-4%:   Detecting libraries (if detected)
                #   4-5%:   Generating function prototypes (if detected)
                #   5%+:    Compiling stage begins
                
                if self.detecting_libraries:
                    # Detecting libraries: 3-4%
                    if self.detect_libs_start_time:
                        lib_detect_elapsed = time.time() - self.detect_libs_start_time
                        percent = min(4.0, 3.0 + (lib_detect_elapsed * 2.0))  # Quick transition
                    else:
                        percent = 3.0
                elif self.generating_prototypes:
                    # Generating prototypes: 4-5%
                    if self.gen_prototypes_start_time:
                        proto_elapsed = time.time() - self.gen_prototypes_start_time
                        percent = min(5.0, 4.0 + (proto_elapsed * 2.0))  # Quick transition
                    else:
                        percent = 4.0
                else:
                    # Basic initialization: 0-3% (time-based, max 3%)
                    percent = min(3.0, 1.0 + (elapsed / 2.0))
                
                # If we've been initializing for more than 10 seconds, force transition
                if elapsed > 10.0:
                    self.stage = CompileStage.COMPILING
                    if self.compile_stage_start_time is None:
                        self.compile_stage_start_time = time.time()
                    # Fall through to compiling stage calculation below
                    # But set a minimum starting point
                    percent = max(percent, 5.0)
            elif self.stage == CompileStage.COMPILING:
                # Compiling: 5-65% with pre-allocated sub-stage ranges:
                #   5-35%:  Compiling libraries (30% of compile range)
                #   35-50%: Compiling core (15% of compile range)
                #   50-65%: Compiling sketch/files (15% of compile range)
                
                # Determine which sub-stage we're in
                if self.compiling_libraries and not self.compiling_core and not self.compiling_sketch:
                    # We're compiling libraries: 5-35%
                    compile_range_start = 5.0
                    compile_range_end = 35.0
                    compile_range_size = 30.0
                elif self.compiling_core and not self.compiling_sketch:
                    # We're compiling core: 35-50%
                    compile_range_start = 35.0
                    compile_range_end = 50.0
                    compile_range_size = 15.0
                elif self.compiling_sketch or (not self.compiling_libraries and not self.compiling_core):
                    # We're compiling sketch/files: 50-65%
                    compile_range_start = 50.0
                    compile_range_end = 65.0
                    compile_range_size = 15.0
                else:
                    # Mixed or unknown - use full range with file-based calculation
                    compile_range_start = 5.0
                    compile_range_end = 65.0
                    compile_range_size = 60.0
                
                if self.total_files > 0 and self.files_compiled >= 0:
                    # Track when we first discovered total_files
                    if self.total_files_discovered_time is None:
                        self.total_files_discovered_time = time.time()
                        self.last_time_based_percent = self.last_percent if self.last_percent > 5.0 else 5.0
                    
                    # Use actual file count ratio for precise progress within current sub-stage range
                    file_progress = min(self.files_compiled / max(self.total_files, 1), 1.0)
                    # Scale file progress to current sub-stage range
                    file_based_percent = compile_range_start + (file_progress * compile_range_size)
                    
                    # Calculate time-based estimate as fallback within current range
                    time_based_percent = min(compile_range_end, compile_range_start + (compile_elapsed * (compile_range_size / 30.0)))
                    
                    # Smooth transition: blend time-based and file-based estimates
                    # Gradually transition over 5 seconds after discovering total_files
                    # Always use some blend to prevent dramatic jumps
                    if self.total_files_discovered_time:
                        transition_time = time.time() - self.total_files_discovered_time
                        if transition_time < 5.0:
                            # Blend: gradually move from time_based to file_based
                            # Start with 80% time-based, end with 100% file-based
                            time_weight = max(0.0, 0.8 - (transition_time / 5.0) * 0.8)
                            file_weight = 1.0 - time_weight
                            percent = (time_based_percent * time_weight) + (file_based_percent * file_weight)
                        else:
                            # After transition, still use slight blend to smooth out variations
                            # 95% file-based, 5% time-based
                            percent = (file_based_percent * 0.95) + (time_based_percent * 0.05)
                    else:
                        percent = file_based_percent
                    
                    # Update last_time_based_percent for reference
                    self.last_time_based_percent = time_based_percent
                    
                    # Ensure we don't go backwards (but allow small decreases for smoothing)
                    if percent < self.last_percent - 2.0:
                        percent = max(self.last_percent - 2.0, percent)
                    
                    # Cap at the end of current compile range
                    if percent > compile_range_end:
                        percent = compile_range_end
                else:
                    # Dynamic estimate when total_files unknown
                    # Use multiple heuristics for better granularity
                    
                    # Heuristic 1: If we have average compile time and files compiled, estimate total
                    if self.avg_file_compile_time > 0 and self.files_compiled > 0:
                        # Estimate: based on how many files we've compiled and their average time
                        # Assume we're maybe 30-50% through discovery phase
                        estimated_files_remaining = max(0, (compile_elapsed / self.avg_file_compile_time) - self.files_compiled)
                        estimated_total = self.files_compiled + int(estimated_files_remaining * 1.5)  # Conservative estimate
                        if estimated_total > 0:
                            file_progress = min(self.files_compiled / max(estimated_total, 1), 0.95)  # Cap at 95% until we know
                            percent = compile_range_start + (file_progress * compile_range_size)
                            self.last_time_based_percent = percent
                        else:
                            # Fall through to time-based within current range
                            percent = min(compile_range_end, compile_range_start + (compile_elapsed * (compile_range_size / 20.0)))
                            self.last_time_based_percent = percent
                    # Heuristic 2: If we're actively compiling files, use time-based with ratio adjustment
                    elif self.files_compiled > 0:
                        # We have some files compiled but don't know total yet
                        # Use a ratio: assume we discover ~2-3 files per second initially
                        # Adjust based on actual compile rate
                        discovery_rate = max(0.5, self.files_compiled / max(compile_elapsed, 1))
                        estimated_total = int(self.files_compiled + (discovery_rate * 10))  # Assume 10 more seconds of discovery
                        if estimated_total > self.files_compiled:
                            file_progress = min(self.files_compiled / max(estimated_total, 1), 0.90)
                            percent = compile_range_start + (file_progress * compile_range_size)
                        else:
                            percent = min(compile_range_end, compile_range_start + (compile_elapsed * (compile_range_size / 25.0)))
                        self.last_time_based_percent = percent
                    else:
                        # No files compiled yet - use time-based within current range
                        percent = min(compile_range_end, compile_range_start + (compile_elapsed * (compile_range_size / 15.0)))
                        self.last_time_based_percent = percent
            elif self.stage == CompileStage.LINKING:
                # Linking: 65-90% (time-based, but more granular)
                if self.link_stage_start_time:
                    link_elapsed = time.time() - self.link_stage_start_time
                else:
                    link_elapsed = 0
                link_progress = min(25.0, link_elapsed * 5.0)  # 5% per second, max 25%
                percent = 65.0 + link_progress
                if percent > 90.0:
                    percent = 90.0
            elif self.stage == CompileStage.GENERATING:
                # Generating: 90-99% (time-based, more granular)
                if self.generate_stage_start_time:
                    gen_elapsed = time.time() - self.generate_stage_start_time
                else:
                    gen_elapsed = 0
                gen_progress = min(9.0, gen_elapsed * 3.0)  # 3% per second, max 9%
                percent = 90.0 + gen_progress
                if percent > 99.0:
                    percent = 99.0
            elif self.stage == CompileStage.COMPLETE:
                percent = 100.0
            else:
                percent = 0.0
            
            # Ensure percent never exceeds 100.0
            percent = min(100.0, percent)
            
            # Only update if percent increased (prevent going backwards)
            # Use small threshold to allow gradual increases
            if percent > self.last_percent:
                self.last_percent = percent
            
            return self.stage, self.current_file, min(100.0, self.last_percent)
    
    def log_line(self, line: str):
        """Log a line to the log file if it exists (thread-safe)."""
        if self.log_file:
            with self.lock:
                self.log_file.write(line)
                self.log_file.flush()
    
    def write_projection_results(self, overwrite_placeholder=False):
        """Write projection calculation results before compilation output."""
        if not self.log_file:
            return
        
        with self.lock:
            # Write section header
            section = "\n" + "=" * 80 + "\n"
            section += "PROJECTION CALCULATION RESULTS\n"
            section += "=" * 80 + "\n\n"
            
            # Current counts
            section += "CURRENT TRACKING COUNTS:\n"
            section += f"  files_compiled:      {self.files_compiled}\n"
            section += f"  total_files:         {self.total_files}\n"
            section += f"  libraries_compiled:  {len(self.libraries_compiled)}\n"
            section += f"  total_libraries:     {self.total_libraries}\n"
            section += f"  current_stage:       {self.stage.value if hasattr(self.stage, 'value') else str(self.stage)}\n"
            section += "\n"
            
            # Library details
            if self.libraries_seen:
                section += "LIBRARIES DETECTED:\n"
                for lib in sorted(self.libraries_seen):
                    compiled = "✓" if lib in self.libraries_compiled else " "
                    file_count = len(self.library_files.get(lib, []))
                    section += f"  [{compiled}] {lib} ({file_count} files)\n"
                section += "\n"
            
            # Projection calculations
            section += "PROJECTION CALCULATIONS:\n"
            if self.total_files > 0:
                file_progress_pct = (self.files_compiled / self.total_files) * 100 if self.total_files > 0 else 0
                section += f"  File progress:       {self.files_compiled}/{self.total_files} files ({file_progress_pct:.1f}%)\n"
            else:
                section += f"  File progress:       {self.files_compiled} files (total unknown)\n"
            
            if self.total_libraries > 0:
                lib_progress_pct = (len(self.libraries_compiled) / self.total_libraries) * 100 if self.total_libraries > 0 else 0
                section += f"  Library progress:    {len(self.libraries_compiled)}/{self.total_libraries} libraries ({lib_progress_pct:.1f}%)\n"
            else:
                section += f"  Library progress:    {len(self.libraries_compiled)} libraries (total unknown)\n"
            
            # Time-based estimates
            elapsed = time.time() - self.start_time
            section += f"  Elapsed time:        {elapsed:.1f} seconds\n"
            
            if self.avg_file_compile_time > 0:
                section += f"  Avg compile time:    {self.avg_file_compile_time:.2f} seconds/file\n"
            
            if self.compile_stage_start_time:
                compile_elapsed = time.time() - self.compile_stage_start_time
                section += f"  Compile stage time:  {compile_elapsed:.1f} seconds\n"
                
                if self.files_compiled > 0 and compile_elapsed > 0:
                    discovery_rate = self.files_compiled / compile_elapsed
                    section += f"  File discovery rate: {discovery_rate:.2f} files/second\n"
                    
                    if self.total_files == 0:
                        # Estimate total based on rate
                        estimated_remaining_time = 10.0  # Assume 10 more seconds
                        estimated_total = int(self.files_compiled + (discovery_rate * estimated_remaining_time))
                        section += f"  Estimated total:     {estimated_total} files (based on discovery rate)\n"
            
            # Sub-stage status
            section += "\nSUB-STAGE STATUS:\n"
            section += f"  Detecting libraries: {'Yes' if self.detecting_libraries else 'No'} (completed: {'Yes' if self.libraries_detected else 'No'})\n"
            section += f"  Generating prototypes: {'Yes' if self.generating_prototypes else 'No'} (completed: {'Yes' if self.prototypes_generated else 'No'})\n"
            section += f"  Compiling libraries: {'Yes' if self.compiling_libraries else 'No'}\n"
            section += f"  Compiling core:      {'Yes' if self.compiling_core else 'No'}\n"
            section += f"  Compiling sketch:    {'Yes' if self.compiling_sketch else 'No'}\n"
            section += f"  Current library:     {self.current_library if self.current_library else '(none)'}\n"
            section += f"  Current file:        {self.current_file if self.current_file else '(none)'}\n"
            
            section += "\n" + "=" * 80 + "\n\n"
            
            self.log_file.write(section)
            self.log_file.flush()
    
    def log_progress_marker(self, percent: float):
        """Log a progress marker when progress increases (thread-safe)."""
        if self.log_file and percent > self.last_logged_percent:
            # Only log on integer percent boundaries
            current_percent_int = int(percent)
            last_percent_int = int(self.last_logged_percent)
            
            if current_percent_int > last_percent_int:
                marker = f"\n{'=' * 42}\n{current_percent_int} % progress\n{'=' * 42}\n"
                with self.lock:
                    self.log_file.write(marker)
                    self.log_file.flush()
                self.last_logged_percent = percent
    
    def write_log_header(self):
        """Write header information to log file explaining tracking and calculations."""
        if not self.log_file:
            return
        
        header = """================================================================================
COMPILATION PROGRESS LOG
================================================================================

TRACKING COUNTS:
----------------
- files_compiled:      Number of files that have finished compiling (object files created)
- total_files:         Total number of files that will be compiled (compiler invocations seen)
- libraries_compiled:  Number of libraries that have finished compiling
- total_libraries:     Total number of unique libraries detected
- compile_lines:       List of all compilation command lines seen (used to count total_files)
- compiled_lines:      List of all compiled file evidence seen (used to count files_compiled)

PROGRESS STAGE RANGES:
----------------------
- INITIALIZING (0-5%):
  * Basic initialization (0-3%)
  * Detecting libraries (3-4%)
  * Generating function prototypes (4-5%)

- COMPILING (5-65%):
  * Compiling libraries (5-35%)
  * Compiling core (35-50%)
  * Compiling sketch/files (50-65%)

- LINKING (65-90%):
  * Linking everything together

- GENERATING (90-99%):
  * Creating ESP32S3 image

- COMPLETE (100%):
  * Compilation finished

PROGRESS INCREASE MARKERS:
--------------------------
Progress increases when:
1. Files are detected being compiled (total_files count increases)
2. Files finish compiling (files_compiled count increases)
3. Libraries are detected (total_libraries count increases)
4. Libraries finish compiling (libraries_compiled count increases)
5. Stage transitions occur (INITIALIZING -> COMPILING -> LINKING -> GENERATING -> COMPLETE)
6. Time-based progress within current stage (if file counts unknown)

CALCULATIONS AND PROJECTIONS:
------------------------------
- File-based progress:    files_compiled / total_files * (stage_range_size) + stage_start
- Library-based progress: libraries_compiled / total_libraries * (library_range_size) + library_start
- Time-based progress:    elapsed_time * rate_factor (fallback when counts unknown)
- Average compile time:   Moving average of last 10 file compile times
- Estimated total files:  Calculated from discovery rate and elapsed time
- File discovery rate:    files_compiled / compile_elapsed_time

DETECTION PATTERNS:
-------------------
- Compiler invocations:   "xtensa-esp32s3-elf-g++" or "xtensa-esp32s3-elf-gcc" with "-c" flag
- Compiling messages:     "Compiling file.cpp", "Compiling library X", "Compiling core"
- Compiled evidence:      ".cpp.o", ".c.o", "gcc-ar", "Compiled file.cpp"
- Stage transitions:      "Detecting libraries", "Generating prototypes", "Linking", "Creating ESP32"

================================================================================
PROJECTION CALCULATION RESULTS:
================================================================================

================================================================================
COMPILATION OUTPUT:
================================================================================

"""
        self.log_file.write(header)
        self.log_file.flush()

 #<

def cmd_progress(): #>
    """Compile with alive_progress progress bar."""
    if not verify_sketch():
        return 1
    
    try:
        from alive_progress import alive_bar
    except ImportError:
        print()  # Ensure we're on a new line
        error("alive_progress not available. Please install alive-progress to use progress bar.")
        error("Install with: pip install alive-progress")
        print()  # Add blank line after error
        return 1
    
    print()
    print(action(f"Compiling {SKETCH_NAME}..."))
    print()
    
    # Create log file in the same directory as pmake
    pmake_dir = Path(__file__).parent.resolve()
    log_file_path = pmake_dir / "pmake.log"
    
    # Open log file for writing
    log_file = open(log_file_path, 'w', encoding='utf-8')
    
    args = [
        "compile",
        "--fqbn", FQBN,
        "--libraries", str(LIBRARY_PATH),
        "--build-path", str(BUILD_PATH),
        "--verbose",  # Enable verbose output so we can log all compilation details
        str(SKETCH_DIR),
    ]
    
    # Create progress monitor with log file
    monitor = ProgressMonitor(log_file=log_file)
    
    # Write log header
    monitor.write_log_header()
    
    # Write initial projection results (will be mostly empty but shows structure)
    # This appears right before compilation output starts
    monitor.write_projection_results()
    
    # Start Arduino CLI process
    cmd = [str(ARDUINO_CLI)] + args
    try:
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
            universal_newlines=True,
        )
    except FileNotFoundError:
        error(f"Arduino CLI not found at: {ARDUINO_CLI}")
        # Close log file if it was opened
        if log_file:
            log_file.close()
        return 1
    
    # Use alive_progress alive_bar
    try:
        all_output = []
        
        def read_output():
            """Read output from process and update monitor."""
            for line in iter(process.stdout.readline, ''):
                if line:
                    all_output.append(line)
                    # Log the line to file
                    monitor.log_line(line)
                    monitor.update_from_line(line)
            process.stdout.close()
        
        # Start thread to read output
        output_thread = threading.Thread(target=read_output, daemon=True)
        output_thread.start()
        
        # Use alive_bar for progress display (0-100)
        # Track calls to bar() to ensure we never exceed 100
        with alive_bar(100, title="Compiling", bar='smooth', spinner='dots') as bar:
            last_percent = 0
            bar_calls_made = 0  # Track how many times we've called bar()
            
            # Wait for compilation to complete, updating progress bar as we go
            while True:
                # Get current progress
                stage, current_file, percent = monitor.get_progress()
                
                # Ensure percent never exceeds 100
                percent = min(100.0, percent)
                
                # Log progress marker if progress increased
                monitor.log_progress_marker(percent)
                
                # Update progress bar text with stage, sub-stage, file info, and progress details
                stage_name = stage.value if hasattr(stage, 'value') else str(stage)
                
                # Add sub-stage information
                sub_stage = ""
                with monitor.lock:
                    if stage == CompileStage.INITIALIZING:
                        if monitor.detecting_libraries:
                            sub_stage = " - Detecting libraries"
                        elif monitor.generating_prototypes:
                            sub_stage = " - Generating prototypes"
                    elif stage == CompileStage.COMPILING:
                        if monitor.compiling_libraries:
                            sub_stage = " - Libraries"
                        elif monitor.compiling_core:
                            sub_stage = " - Core"
                        elif monitor.compiling_sketch:
                            sub_stage = " - Sketch"
                    
                    files_info = ""
                    # Show library counts when compiling libraries
                    if stage == CompileStage.COMPILING and monitor.compiling_libraries:
                        libs_compiled = len(monitor.libraries_compiled)
                        if monitor.total_libraries > 0:
                            files_info = f" [{libs_compiled}/{monitor.total_libraries} libs"
                        elif libs_compiled > 0:
                            files_info = f" [{libs_compiled} libs"
                        
                        # Add file count if we have it
                        if monitor.total_files > 0:
                            if files_info:
                                files_info += f", {monitor.files_compiled}/{monitor.total_files} files]"
                            else:
                                files_info = f" [{monitor.files_compiled}/{monitor.total_files} files]"
                        elif monitor.files_compiled > 0:
                            if files_info:
                                files_info += f", {monitor.files_compiled} files]"
                            else:
                                files_info = f" [{monitor.files_compiled} files]"
                        elif files_info:
                            files_info += "]"
                    else:
                        # Standard file count display for other stages
                        if monitor.total_files > 0:
                            files_info = f" [{monitor.files_compiled}/{monitor.total_files} files]"
                        elif monitor.files_compiled > 0:
                            files_info = f" [{monitor.files_compiled} files]"
                
                if current_file:
                    bar.text(f"{stage_name}{sub_stage} - {current_file[:25]}{files_info} ({percent:.1f}%)")
                else:
                    bar.text(f"{stage_name}{sub_stage}{files_info} ({percent:.1f}%)")
                
                # Update progress bar - only advance if we haven't exceeded 100 calls
                # Limit advancement to prevent large jumps (max 5% per cycle)
                current_percent_int = min(100, int(percent))
                if current_percent_int > last_percent and bar_calls_made < 100:
                    # Cap the advancement to prevent dramatic jumps
                    max_advance = min(5, current_percent_int - last_percent)
                    target_percent = min(100, last_percent + max_advance)
                    
                    # Calculate how many steps to advance
                    steps_to_advance = target_percent - last_percent
                    # Ensure we don't exceed 100 total calls
                    remaining_calls = 100 - bar_calls_made
                    steps_to_advance = min(steps_to_advance, remaining_calls)
                    
                    # Advance the progress bar
                    for _ in range(steps_to_advance):
                        bar()
                        bar_calls_made += 1
                        if bar_calls_made >= 100:
                            break
                    
                    last_percent = last_percent + steps_to_advance
                
                # Break if compilation is complete AND we've read all output
                # This ensures we capture all summary lines (libraries, platform, etc.)
                if stage == CompileStage.COMPLETE:
                    # Wait a bit for any remaining summary lines to be read
                    # Then check if process and thread are done
                    if process.poll() is not None:
                        # Process is done, wait for thread to finish reading
                        if not output_thread.is_alive():
                            # Fill remaining progress to 100%
                            remaining = max(0, 100 - bar_calls_made)
                            for _ in range(remaining):
                                bar()
                                bar_calls_made += 1
                            last_percent = 100
                            break
                    else:
                        # Process still running, but stage is complete - fill to 100% but keep waiting
                        remaining = max(0, 100 - bar_calls_made)
                        for _ in range(remaining):
                            bar()
                            bar_calls_made += 1
                        last_percent = 100
                
                # Also break if process is done and thread is finished
                if process.poll() is not None and not output_thread.is_alive():
                    # Fill remaining progress to 100%
                    remaining = max(0, 100 - bar_calls_made)
                    for _ in range(remaining):
                        bar()
                        bar_calls_made += 1
                    last_percent = 100
                    break
                
                # Small sleep to avoid busy-waiting
                time.sleep(0.1)
        
        # Wait for process to complete
        return_code = process.wait()
        
        # Wait for output thread to finish reading all output
        output_thread.join(timeout=10)
        
        # Give a small additional delay to ensure all buffered output is captured
        time.sleep(0.5)
        
        # Write final projection results showing completed calculations
        monitor.write_projection_results()
        
        print()  # New line after progress bar
        
        # Display original compilation summary with original colors
        # Always extract from all_output to ensure we get the complete summary
        summary_lines = []
        
        # Strategy: Find "Sketch uses" and extract everything from there to the end
        # Also look for "Used library" and "Used platform" to verify we have complete summary
        summary_start = -1
        has_library_section = False
        has_platform_section = False
        
        for i, line in enumerate(all_output):
            line_lower = line.lower()
            if "sketch uses" in line_lower and summary_start == -1:
                summary_start = i
            if "used library" in line_lower:
                has_library_section = True
            if "used platform" in line_lower:
                has_platform_section = True
        
        if summary_start >= 0:
            # Extract all lines from summary start to end
            summary_lines = [line.rstrip() for line in all_output[summary_start:]]
            
            # Remove trailing completely empty lines
            while summary_lines and not summary_lines[-1]:
                summary_lines.pop()
            
            # If we found library/platform markers but they're not in our extracted lines,
            # re-extract to include them
            if (has_library_section or has_platform_section) and len(summary_lines) <= 2:
                # Re-search more carefully - find the actual end of summary
                # Look backwards from library/platform to find start
                library_start = -1
                for i, line in enumerate(all_output):
                    if "used library" in line.lower():
                        library_start = i
                        break
                
                if library_start > 0:
                    # Extract from "Sketch uses" to end of output (or a reasonable stopping point)
                    summary_lines = [line.rstrip() for line in all_output[summary_start:]]
                    while summary_lines and not summary_lines[-1]:
                        summary_lines.pop()
        
        # Final fallback: use monitor's captured lines
        if not summary_lines:
            summary_lines = monitor.summary_lines
        
        if summary_lines:
            print()  # Blank line before summary
            # Log summary to file
            if log_file:
                log_file.write("\n")
                log_file.write("=" * 42 + "\n")
                log_file.write("COMPILATION SUMMARY\n")
                log_file.write("=" * 42 + "\n")
            # Print summary lines as-is (preserving original colors/formatting)
            for summary_line in summary_lines:
                print(summary_line)
                # Also log to file (strip ANSI codes for log)
                if log_file:
                    # Remove ANSI escape codes for log file
                    ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
                    clean_line = ansi_escape.sub('', summary_line)
                    log_file.write(clean_line + "\n")
            print()  # Blank line after summary
            if log_file:
                log_file.write("\n")
                log_file.flush()
        else:
            # Debug: If no summary found, show last 20 lines of output to diagnose
            print()  # Blank line
            info("No summary found in output. Last 20 lines of output:")
            for line in all_output[-20:]:
                if line.strip():
                    print(f"  {line.rstrip()}")
            print()
        
        if return_code == 0:
            success("Compilation successful!")
            # Close log file
            if log_file:
                log_file.close()
            return 0
        else:
            error("Compilation failed!")
            
            # Show compilation errors
            if all_output:
                print()
                error("Compilation output (errors):")
                error_lines = []
                for line in all_output:
                    line_lower = line.lower().strip()
                    if line_lower and any(keyword in line_lower for keyword in [
                        "error", "fatal", "undefined", "multiple definition", 
                        "has no member", "error during build", "exit status"
                    ]):
                        error_lines.append(line.strip())
                
                if error_lines:
                    for err in error_lines[:20]:
                        print(f"  {err}")
                else:
                    print("  Last output lines:")
                    for line in all_output[-30:]:
                        if line.strip():
                            print(f"  {line.strip()}")
            
            # Close log file
            if log_file:
                log_file.close()
            return 1
            
    except KeyboardInterrupt:
        print()
        warning("Compilation interrupted by user")
        process.terminate()
        # Close log file
        if log_file:
            log_file.close()
        return 1
    except Exception as e:
        error(f"Error during compilation: {e}")
        # Close log file
        if log_file:
            log_file.close()
        return 1

 #<

def cmd_upload(): #>
    """Upload to ESP32-S3."""
    write_header_fat("Uploading")
    print()
    action(f"Uploading to ESP32-S3 on {PORT}...")
    print()
    
    args = [
        "upload",
        "-p", PORT,
        "--fqbn", FQBN,
        "--build-path", str(BUILD_PATH),
        str(SKETCH_DIR),
    ]
    
    result = run_arduino_cli(args)
    
    if result.returncode == 0:
        print()
        success("Upload successful!")
        return 0
    else:
        print()
        error("Upload failed!")
        return 1

 #<

def cmd_monitor(): #>
    """Open serial monitor."""
    action(f"Opening serial monitor on {PORT} at {BAUDRATE} baud...")
    args = [
        "monitor",
        "-p", PORT,
        "--config", f"baudrate={BAUDRATE}",
    ]
    
    # Monitor runs until user exits
    run_arduino_cli(args)

 #<

def cmd_clean(): #>
    """Clean build artifacts."""
    write_header_fat("Cleaning")
    print()
    action("Cleaning build artifacts...")
    
    # Remove build directory
    if BUILD_PATH.exists():
        shutil.rmtree(BUILD_PATH)
    
    # Run Arduino CLI clean
    args = [
        "compile",
        "--fqbn", FQBN,
        "--clean",
        str(SKETCH_DIR),
    ]
    
    run_arduino_cli(args)
    success("Clean complete!")

 #<

def cmd_all(): #>
    """Compile and upload in one step."""
    if cmd_compile() == 0:
        print()
        if cmd_upload() == 0:
            print()
            success("Build and upload complete!")
            return 0
    
    return 1
 
 #<




def main(): #>
    """Main entry point."""
    # If no command provided, show interactive action selection
    if len(sys.argv) < 2:
        selected_action = select_action_interactive()
        if not selected_action:
            return 1
        command = selected_action
    else:
        command = sys.argv[1]
    
    commands = { #>
        "Help": cmd_help,
        "Build": lambda: cmd_compile(),
        "Compile": lambda: cmd_compile(),
        "Progress": cmd_progress,
        "Upload": cmd_upload,
        "Monitor": cmd_monitor,
        "Clean": cmd_clean,
        "All": cmd_all,
    } #<
    
    # Normalize command to match dictionary keys (capitalize first letter, case-insensitive)
    command_normalized = command.capitalize() if command else None
    
    if command_normalized and command_normalized in commands:
        try:
            result = commands[command_normalized]()
            return result if result is not None else 0
        except KeyboardInterrupt:
            print()
            error("Operation cancelled by user")
            return 1
        except Exception as e:
            import traceback
            error(f"Error: {e}")
            traceback.print_exc()
            return 1
    else:
        error(f"Unknown command: {command}")
        print()
        cmd_help()
        return 1

if __name__ == "__main__":
    sys.exit(main())

 #<