#!/usr/bin/env python3
"""
Test script to display headers in colors with >0.51 contrast to #0C0D0E,
followed by formatted status messages per terminal-output.mdc rules.
"""

import sys
import os
import math

# Add pyprompt to path
pyprompt_path = os.path.join(os.path.dirname(__file__), "___shared", "shared-python", "pyprompt")
if os.path.exists(pyprompt_path):
    sys.path.insert(0, pyprompt_path)

from pyprompt import select, text, HAS_PROMPT_TOOLKIT # type: ignore

# Enable ANSI colors on Windows 10+
if sys.platform == "win32":
    try:
        import ctypes
        kernel32 = ctypes.windll.kernel32
        kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)
    except Exception:
        pass

# Color constants from terminal-output.mdc
COLOR_ERROR = "\x1B[38;5;196m"      # Bright red (#ff0000) - Code 196
COLOR_WARNING = "\x1B[38;5;220m"   # Bright gold/yellow (#ffd700) - Code 220
COLOR_INFO = "\x1B[38;5;39m"       # Bright blue (#00afff) - Code 39
COLOR_SUCCESS = "\x1B[38;5;46m"    # Bright green (#00ff00) - Code 46
COLOR_WHITE = "\x1B[38;5;15m"      # White (#ffffff) - Code 15
COLOR_BOLD = "\x1B[1m"              # Bold text
COLOR_RESET = "\x1B[0m"             # Reset all formatting

# Icons
ICON_ERROR = "✗"                    # Error icon (U+2717)
ICON_WARNING = "⚠"                  # Warning icon (U+26A0)
ICON_INFO = "ｉ"                    # Info icon (full-width i, U+FF49)
ICON_SUCCESS = "✔"                  # Success icon (heavy checkmark, U+2714)

# Background color to test against
BG_COLOR = (12, 13, 14)  # #0C0D0E


def ansi_code_to_rgb(code: int) -> tuple[int, int, int]:
    """Convert ANSI 256-color code to RGB tuple."""
    if 0 <= code <= 15:
        # Standard 16 colors
        color_values = [
            (0, 0, 0),       # Black
            (128, 0, 0),     # Red
            (0, 128, 0),     # Green
            (128, 128, 0),   # Yellow
            (0, 0, 128),     # Blue
            (128, 0, 128),   # Magenta
            (0, 128, 128),   # Cyan
            (192, 192, 192), # White
            (128, 128, 128), # Bright Black (Gray)
            (255, 0, 0),     # Bright Red
            (0, 255, 0),     # Bright Green
            (255, 255, 0),   # Bright Yellow
            (0, 0, 255),     # Bright Blue
            (255, 0, 255),   # Bright Magenta
            (0, 255, 255),   # Bright Cyan
            (255, 255, 255), # Bright White
        ]
        return color_values[code]
    elif 16 <= code <= 231:
        # 216-color cube (6x6x6)
        code_offset = code - 16
        r = (code_offset // 36) * 51
        g = ((code_offset // 6) % 6) * 51
        b = (code_offset % 6) * 51
        return (r, g, b)
    elif 232 <= code <= 255:
        # Grayscale ramp
        gray_level = 8 + 10 * (code - 232)
        return (gray_level, gray_level, gray_level)
    else:
        raise ValueError(f"Invalid ANSI color code: {code}")


def rgb_to_hex(r: int, g: int, b: int) -> str:
    """Convert RGB values to hex string."""
    return f"#{r:02x}{g:02x}{b:02x}"


def rgb_to_xyz(r: int, g: int, b: int) -> tuple[float, float, float]:
    """Convert RGB to XYZ color space (D65 illuminant)."""
    # Normalize RGB to 0-1
    r_norm = r / 255.0
    g_norm = g / 255.0
    b_norm = b / 255.0
    
    # Apply gamma correction
    def gamma_correct(c: float) -> float:
        if c <= 0.04045:
            return c / 12.92
        else:
            return ((c + 0.055) / 1.055) ** 2.4
    
    r_lin = gamma_correct(r_norm)
    g_lin = gamma_correct(g_norm)
    b_lin = gamma_correct(b_norm)
    
    # Convert to XYZ (sRGB to XYZ matrix)
    x = r_lin * 0.4124564 + g_lin * 0.3575761 + b_lin * 0.1804375
    y = r_lin * 0.2126729 + g_lin * 0.7151522 + b_lin * 0.0721750
    z = r_lin * 0.0193339 + g_lin * 0.1191920 + b_lin * 0.9503041
    
    return (x, y, z)


def xyz_to_lab(x: float, y: float, z: float) -> tuple[float, float, float]:
    """Convert XYZ to LAB color space."""
    # D65 white point
    xn, yn, zn = 0.95047, 1.00000, 1.08883
    
    # Normalize by white point
    x_norm = x / xn
    y_norm = y / yn
    z_norm = z / zn
    
    # Apply f function
    def f(t: float) -> float:
        if t > (6/29)**3:
            return t ** (1/3)
        else:
            return (1/3) * ((29/6)**2) * t + 4/29
    
    fx = f(x_norm)
    fy = f(y_norm)
    fz = f(z_norm)
    
    L = 116 * fy - 16
    a = 500 * (fx - fy)
    b = 200 * (fy - fz)
    
    return (L, a, b)


def rgb_to_lab(r: int, g: int, b: int) -> tuple[float, float, float]:
    """Convert RGB to LAB color space."""
    x, y, z = rgb_to_xyz(r, g, b)
    return xyz_to_lab(x, y, z)


def lab_to_lch(L: float, a: float, b: float) -> tuple[float, float, float]:
    """Convert LAB to LCH color space."""
    C = math.sqrt(a * a + b * b)
    H = math.degrees(math.atan2(b, a))
    if H < 0:
        H += 360
    return (L, C, H)


def relative_luminance(rgb: tuple[int, int, int]) -> float:
    """Calculate relative luminance using WCAG formula."""
    def linearize(component: int) -> float:
        """Linearize RGB component."""
        normalized = component / 255.0
        if normalized <= 0.03928:
            return normalized / 12.92
        else:
            return ((normalized + 0.055) / 1.055) ** 2.4
    
    r, g, b = rgb
    r_lin = linearize(r)
    g_lin = linearize(g)
    b_lin = linearize(b)
    
    return 0.2126 * r_lin + 0.7152 * g_lin + 0.0722 * b_lin


def contrast_ratio(rgb1: tuple[int, int, int], rgb2: tuple[int, int, int]) -> float:
    """Calculate WCAG contrast ratio between two RGB colors."""
    l1 = relative_luminance(rgb1)
    l2 = relative_luminance(rgb2)
    
    # Ensure lighter color is in numerator
    if l1 < l2:
        l1, l2 = l2, l1
    
    return (l1 + 0.05) / (l2 + 0.05)


def delta_e_cie76(rgb1: tuple[int, int, int], rgb2: tuple[int, int, int]) -> float:
    """Calculate Delta E (CIE76) color difference."""
    L1, a1, b1 = rgb_to_lab(*rgb1)
    L2, a2, b2 = rgb_to_lab(*rgb2)
    
    return math.sqrt((L1 - L2)**2 + (a1 - a2)**2 + (b1 - b2)**2)


def delta_e_cie94(rgb1: tuple[int, int, int], rgb2: tuple[int, int, int]) -> float:
    """Calculate Delta E (CIE94) color difference (improved version)."""
    L1, a1, b1 = rgb_to_lab(*rgb1)
    L2, a2, b2 = rgb_to_lab(*rgb2)
    
    C1 = math.sqrt(a1**2 + b1**2)
    C2 = math.sqrt(a2**2 + b2**2)
    
    dL = L1 - L2
    dC = C1 - C2
    dH = math.sqrt((a1 - a2)**2 + (b1 - b2)**2 - dC**2)
    
    kL, kC, kH = 1.0, 1.0, 1.0
    K1, K2 = 0.045, 0.015
    
    SL = 1.0
    SC = 1.0 + K1 * C1
    SH = 1.0 + K2 * C1
    
    return math.sqrt((dL / (kL * SL))**2 + (dC / (kC * SC))**2 + (dH / (kH * SH))**2)


def delta_e_cie2000(rgb1: tuple[int, int, int], rgb2: tuple[int, int, int]) -> float:
    """Calculate Delta E (CIEDE2000) color difference (most accurate)."""
    # Simplified CIEDE2000 - full implementation is complex
    # Using CIE94 as approximation for now
    return delta_e_cie94(rgb1, rgb2)


def lab_euclidean_distance(rgb1: tuple[int, int, int], rgb2: tuple[int, int, int]) -> float:
    """Calculate Euclidean distance in LAB color space."""
    L1, a1, b1 = rgb_to_lab(*rgb1)
    L2, a2, b2 = rgb_to_lab(*rgb2)
    
    return math.sqrt((L1 - L2)**2 + (a1 - a2)**2 + (b1 - b2)**2)


def lch_chroma_difference(rgb1: tuple[int, int, int], rgb2: tuple[int, int, int]) -> float:
    """Calculate chroma (saturation) difference in LCH color space."""
    L1, a1, b1 = rgb_to_lab(*rgb1)
    L2, a2, b2 = rgb_to_lab(*rgb2)
    
    _, C1, _ = lab_to_lch(L1, a1, b1)
    _, C2, _ = lab_to_lch(L2, a2, b2)
    
    return abs(C1 - C2)


def chromatic_contrast(rgb1: tuple[int, int, int], rgb2: tuple[int, int, int]) -> float:
    """Calculate chromatic contrast (color difference in a*b* plane)."""
    L1, a1, b1 = rgb_to_lab(*rgb1)
    L2, a2, b2 = rgb_to_lab(*rgb2)
    
    # Distance in a*b* plane (ignoring lightness)
    return math.sqrt((a1 - a2)**2 + (b1 - b2)**2)


def perceptual_contrast_score(rgb1: tuple[int, int, int], rgb2: tuple[int, int, int]) -> float:
    """Calculate combined perceptual contrast score."""
    wcag = contrast_ratio(rgb1, rgb2)
    delta_e = delta_e_cie76(rgb1, rgb2)
    chroma_diff = lch_chroma_difference(rgb1, rgb2)
    
    # Normalize and combine (weights can be adjusted)
    # Scale delta_e to similar range as WCAG (rough approximation)
    normalized_delta_e = delta_e / 50.0  # Rough scaling
    normalized_chroma = chroma_diff / 50.0  # Rough scaling
    
    # Combined score (weighted)
    return 0.4 * wcag + 0.4 * normalized_delta_e + 0.2 * normalized_chroma


def saturation_ratio(rgb1: tuple[int, int, int], rgb2: tuple[int, int, int]) -> float:
    """Calculate saturation ratio (how much more saturated one color is)."""
    L1, a1, b1 = rgb_to_lab(*rgb1)
    L2, a2, b2 = rgb_to_lab(*rgb2)
    
    _, C1, _ = lab_to_lch(L1, a1, b1)
    _, C2, _ = lab_to_lch(L2, a2, b2)
    
    # Handle zero chroma cases
    if C1 == 0 and C2 == 0:
        return 1.0  # Both are grayscale
    if C1 == 0:
        return 0.0  # First color is grayscale, second is not
    if C2 == 0:
        return float('inf')  # Second color is grayscale, first is not
    
    return C1 / C2 if C1 >= C2 else C2 / C1


# Metric function type
from typing import Callable
MetricFunction = Callable[[tuple[int, int, int], tuple[int, int, int]], float]

METRIC_FUNCTIONS: dict[str, tuple[MetricFunction, str]] = {
    "wcag": (contrast_ratio, "WCAG Contrast Ratio"),
    "delta_e_76": (delta_e_cie76, "Delta E (CIE76)"),
    "delta_e_94": (delta_e_cie94, "Delta E (CIE94)"),
    "delta_e_2000": (delta_e_cie2000, "Delta E (CIEDE2000)"),
    "lab_euclidean": (lab_euclidean_distance, "LAB Euclidean Distance"),
    "lch_chroma": (lch_chroma_difference, "LCH Chroma Difference"),
    "chromatic": (chromatic_contrast, "Chromatic Contrast"),
    "perceptual": (perceptual_contrast_score, "Perceptual Contrast Score"),
    "saturation": (saturation_ratio, "Saturation Ratio"),
}


def prompt_metric_selection() -> tuple[str, MetricFunction, str]:
    """Prompt user to select a contrast metric."""
    if not HAS_PROMPT_TOOLKIT:
        raise ImportError("prompt_toolkit is required. Install pyprompt dependencies.")
    
    choices = [
        "WCAG Contrast Ratio (standard accessibility)",
        "Delta E (CIE76) - Simple color difference",
        "Delta E (CIE94) - Improved color difference",
        "Delta E (CIEDE2000) - Most accurate color difference",
        "LAB Euclidean Distance - Perceptually uniform",
        "LCH Chroma Difference - Saturation-based",
        "Chromatic Contrast - Color difference (ignores lightness)",
        "Perceptual Contrast Score - Combined metric",
        "Saturation Ratio - How much more saturated",
    ]
    
    choice = select("Select contrast/distinction metric:", choices)
    
    if choice is None:
        # Default to WCAG
        return ("wcag", contrast_ratio, "WCAG Contrast Ratio")
    
    metric_map = {
        choices[0]: "wcag",
        choices[1]: "delta_e_76",
        choices[2]: "delta_e_94",
        choices[3]: "delta_e_2000",
        choices[4]: "lab_euclidean",
        choices[5]: "lch_chroma",
        choices[6]: "chromatic",
        choices[7]: "perceptual",
        choices[8]: "saturation",
    }
    
    metric_key = metric_map.get(choice, "wcag")
    metric_func, metric_name = METRIC_FUNCTIONS[metric_key]
    
    return (metric_key, metric_func, metric_name)


def find_colors_with_metric(
    metric_func: MetricFunction,
    min_value: float = 0.0, 
    max_value: float | None = None
) -> list[tuple[int, tuple[int, int, int], float]]:
    """Find all ANSI 256-color codes with metric value in the specified range against BG_COLOR."""
    qualifying_colors = []
    
    for code in range(256):
        rgb = ansi_code_to_rgb(code)
        value = metric_func(rgb, BG_COLOR)
        
        # Check if value is in range
        if value >= min_value:
            if max_value is None or value < max_value:
                qualifying_colors.append((code, rgb, value))
    
    # Sort by metric value (highest first)
    qualifying_colors.sort(key=lambda x: x[2], reverse=True)
    return qualifying_colors


def categorize_color(rgb: tuple[int, int, int]) -> str:
    """Categorize a color by its dominant hue."""
    r, g, b = rgb
    
    # Calculate hue-based categorization
    max_component = max(r, g, b)
    min_component = min(r, g, b)
    
    # Grayscale colors
    if abs(r - g) < 20 and abs(g - b) < 20 and abs(r - b) < 20:
        if max_component < 100:
            return "gray"
        else:
            return "white"
    
    # Determine dominant color
    if r > g and r > b:
        if r - g > 50 and r - b > 50:
            return "red"
        elif abs(r - g) < 30:
            return "yellow"
        else:
            return "orange"
    elif g > r and g > b:
        if g - r > 50 and g - b > 50:
            return "green"
        elif abs(g - b) < 30:
            return "cyan"
        else:
            return "yellow"
    elif b > r and b > g:
        if b - r > 50 and b - g > 50:
            return "blue"
        elif abs(b - r) < 30:
            return "magenta"
        else:
            return "cyan"
    elif r > 200 and g > 200 and b < 100:
        return "yellow"
    elif r > 200 and b > 200 and g < 100:
        return "magenta"
    elif g > 200 and b > 200 and r < 100:
        return "cyan"
    else:
        return "other"


def filter_colors_by_category(
    colors: list[tuple[int, tuple[int, int, int], float]], 
    category: str
) -> list[tuple[int, tuple[int, int, int], float]]:
    """Filter colors by category."""
    if category == "all":
        return colors
    
    filtered = []
    for code, rgb, ratio in colors:
        color_category = categorize_color(rgb)
        if color_category == category:
            filtered.append((code, rgb, ratio))
    return filtered


def parse_custom_ratio(ratio_str: str) -> tuple[float | None, float | None]:
    """
    Parse custom ratio string into min and max values.
    
    Formats:
    - "5" -> (5.0, None)  # 5:1 and up
    - ",5" -> (0.0, 5.0)  # Below 5:1
    - "5,10" -> (5.0, 10.0)  # Between 5:1 and 10:1
    
    Returns:
        Tuple of (min_contrast, max_contrast)
    """
    ratio_str = ratio_str.strip()
    
    if ',' in ratio_str:
        parts = ratio_str.split(',')
        if len(parts) != 2:
            raise ValueError("Invalid format. Use 'min,max' or ',max' or 'min,'")
        
        min_part = parts[0].strip()
        max_part = parts[1].strip()
        
        min_contrast = float(min_part) if min_part else 0.0
        max_contrast = float(max_part) if max_part else None
        
        if min_contrast < 0 or (max_contrast is not None and max_contrast < 0):
            raise ValueError("Ratios must be non-negative")
        if max_contrast is not None and min_contrast >= max_contrast:
            raise ValueError("Minimum must be less than maximum")
        
        return (min_contrast, max_contrast)
    else:
        # Single value means that value and up
        min_contrast = float(ratio_str)
        if min_contrast < 0:
            raise ValueError("Ratio must be non-negative")
        return (min_contrast, None)


def get_metric_ranges(metric_key: str) -> dict[str, tuple[float, float | None]]:
    """
    Get predefined ranges for a metric.
    
    Returns:
        Dictionary mapping range names to (min, max) tuples
    """
    ranges = {
        "delta_e_76": {
            "Low": (0.0, 40.0),
            "Moderate": (40.0, 70.0),
            "Moderate+": (70.0, 100.0),
            "High": (100.0, None),
        },
        "delta_e_94": {
            "Low": (0.0, 30.0),
            "Moderate": (30.0, 55.0),
            "Moderate+": (55.0, 75.0),
            "High": (75.0, None),
        },
        "delta_e_2000": {
            "Low": (0.0, 30.0),
            "Moderate": (30.0, 55.0),
            "Moderate+": (55.0, 75.0),
            "High": (75.0, None),
        },
        "lab_euclidean": {
            "Low": (0.0, 40.0),
            "Moderate": (40.0, 70.0),
            "Moderate+": (70.0, 100.0),
            "High": (100.0, None),
        },
        "lch_chroma": {
            "Low": (0.0, 30.0),
            "Moderate": (30.0, 60.0),
            "Moderate+": (60.0, 85.0),
            "High": (85.0, None),
        },
        "chromatic": {
            "Low": (0.0, 30.0),
            "Moderate": (30.0, 60.0),
            "Moderate+": (60.0, 85.0),
            "High": (85.0, None),
        },
        "perceptual": {
            "Low": (0.0, 2.5),
            "Moderate": (2.5, 4.5),
            "Moderate+": (4.5, 6.5),
            "High": (6.5, None),
        },
        "saturation": {
            "Low": (50.0, 100.0),
            "Moderate": (100.0, 150.0),
            "Moderate+": (150.0, 250.0),
            "High": (250.0, None),
        },
    }
    return ranges.get(metric_key, {})


def prompt_value_range(metric_name: str, metric_key: str = "", is_wcag: bool = False) -> tuple[float | None, float | None, str]:
    """
    Prompt user to select a value range using pyprompt.
    
    Args:
        metric_name: Name of the metric being used
        metric_key: Key identifier for the metric (for range lookup)
        is_wcag: If True, show WCAG-specific ranges
    
    Returns:
        Tuple of (min_value, max_value, display_string)
    """
    if not HAS_PROMPT_TOOLKIT:
        raise ImportError("prompt_toolkit is required. Install pyprompt dependencies.")
    
    if is_wcag:
        choices = [
            "3:1 - WCAG 2.1 Graphics/UI (Level AA) [3.0 to 4.5)",
            "4.5:1 - WCAG 2.0 Normal Text (Level AA) [4.5 to 7.0)",
            "7:1 - WCAG Normal Text (Level AAA) [7.0 and up]",
            "Custom value range",
            "All colors (no minimum)",
        ]
    else:
        # Get predefined ranges for this metric
        metric_ranges = get_metric_ranges(metric_key)
        
        if metric_ranges:
            # Format range values
            low_max = f"{metric_ranges['Low'][1]:.0f}" if metric_ranges['Low'][1] else "max"
            mod_max = f"{metric_ranges['Moderate'][1]:.0f}" if metric_ranges['Moderate'][1] else "max"
            mod_plus_max = f"{metric_ranges['Moderate+'][1]:.0f}" if metric_ranges['Moderate+'][1] else "max"
            
            choices = [
                f"Low [{metric_ranges['Low'][0]:.0f} to {low_max}]",
                f"Moderate [{metric_ranges['Moderate'][0]:.0f} to {mod_max}]",
                f"Moderate+ [{metric_ranges['Moderate+'][0]:.0f} to {mod_plus_max}]",
                f"High [{metric_ranges['High'][0]:.0f} and up]",
                "Custom value range",
                "All colors (no minimum)",
            ]
        else:
            choices = [
                "Custom value range",
                "All colors (no minimum)",
            ]
    
    choice = select(f"Select {metric_name} range:", choices)
    
    if choice is None:
        return (None, None, "")
    
    if is_wcag:
        if choice == choices[0]:  # 3:1 to 4.5
            return (3.0, 4.5, "3.0:1 to 4.5:1")
        elif choice == choices[1]:  # 4.5:1 to 7.0
            return (4.5, 7.0, "4.5:1 to 7.0:1")
        elif choice == choices[2]:  # 7:1 and up
            return (7.0, None, "7.0:1 and up")
        elif choice == choices[3]:  # Custom
            while True:
                ratio_input = text(
                    "Enter custom range (format: '5' for 5+, ',5' for <5, '5,10' for 5-10):",
                    default=""
                )
                if ratio_input is None:
                    return (None, None, "")
                
                try:
                    min_val, max_val = parse_custom_ratio(ratio_input)
                    
                    # Build display string
                    if max_val is None:
                        if min_val == 0.0:
                            display = "all colors"
                        else:
                            display = f"{min_val:.1f} and up"
                    elif min_val == 0.0:
                        display = f"below {max_val:.1f}"
                    else:
                        display = f"{min_val:.1f} to {max_val:.1f}"
                    
                    return (min_val, max_val, display)
                except ValueError as e:
                    print(f"Error: {e}")
                    continue
        else:  # All colors
            return (0.0, None, "all colors")
    else:
        # Non-WCAG metrics: predefined ranges or custom
        metric_ranges = get_metric_ranges(metric_key)
        
        if metric_ranges:
            # Check which predefined range was selected
            if choice == choices[0]:  # Low
                min_val, max_val = metric_ranges["Low"]
                max_str = f"{max_val:.0f}" if max_val else "max"
                display = f"{min_val:.0f} to {max_str}"
                return (min_val, max_val, display)
            elif choice == choices[1]:  # Moderate
                min_val, max_val = metric_ranges["Moderate"]
                max_str = f"{max_val:.0f}" if max_val else "max"
                display = f"{min_val:.0f} to {max_str}"
                return (min_val, max_val, display)
            elif choice == choices[2]:  # Moderate+
                min_val, max_val = metric_ranges["Moderate+"]
                max_str = f"{max_val:.0f}" if max_val else "max"
                display = f"{min_val:.0f} to {max_str}"
                return (min_val, max_val, display)
            elif choice == choices[3]:  # High
                min_val, max_val = metric_ranges["High"]
                display = f"{min_val:.0f} and up"
                return (min_val, max_val, display)
            elif choice == choices[4]:  # Custom
                while True:
                    ratio_input = text(
                        "Enter custom range (format: '5' for 5+, ',5' for <5, '5,10' for 5-10):",
                        default=""
                    )
                    if ratio_input is None:
                        return (None, None, "")
                    
                    try:
                        min_val, max_val = parse_custom_ratio(ratio_input)
                        
                        # Build display string
                        if max_val is None:
                            if min_val == 0.0:
                                display = "all colors"
                            else:
                                display = f"{min_val:.1f} and up"
                        elif min_val == 0.0:
                            display = f"below {max_val:.1f}"
                        else:
                            display = f"{min_val:.1f} to {max_val:.1f}"
                        
                        return (min_val, max_val, display)
                    except ValueError as e:
                        print(f"Error: {e}")
                        continue
            elif choice == choices[5]:  # All colors
                return (0.0, None, "all colors")
        else:
            # No predefined ranges - only custom or all
            if choice == choices[0]:  # Custom
                while True:
                    ratio_input = text(
                        "Enter custom range (format: '5' for 5+, ',5' for <5, '5,10' for 5-10):",
                        default=""
                    )
                    if ratio_input is None:
                        return (None, None, "")
                    
                    try:
                        min_val, max_val = parse_custom_ratio(ratio_input)
                        
                        # Build display string
                        if max_val is None:
                            if min_val == 0.0:
                                display = "all colors"
                            else:
                                display = f"{min_val:.1f} and up"
                        elif min_val == 0.0:
                            display = f"below {max_val:.1f}"
                        else:
                            display = f"{min_val:.1f} to {max_val:.1f}"
                        
                        return (min_val, max_val, display)
                    except ValueError as e:
                        print(f"Error: {e}")
                        continue
            else:  # All colors
                return (0.0, None, "all colors")


def prompt_color_category() -> str:
    """Prompt user to select a color category using pyprompt."""
    if not HAS_PROMPT_TOOLKIT:
        raise ImportError("prompt_toolkit is required. Install pyprompt dependencies.")
    
    choices = [
        "Red colors",
        "Blue colors",
        "Yellow colors",
        "Green colors",
        "Cyan colors",
        "Magenta colors",
        "Orange colors",
        "Gray colors",
        "White colors",
        "Other colors",
        "All colors",
    ]
    
    category_map = {
        "Red colors": "red",
        "Blue colors": "blue",
        "Yellow colors": "yellow",
        "Green colors": "green",
        "Cyan colors": "cyan",
        "Magenta colors": "magenta",
        "Orange colors": "orange",
        "Gray colors": "gray",
        "White colors": "white",
        "Other colors": "other",
        "All colors": "all",
    }
    
    choice = select("Select a color category:", choices)
    
    if choice is None:
        return "all"  # Default to all if cancelled
    
    return category_map.get(choice, "all")


def format_header(
    title: str, 
    color_code: int, 
    rgb: tuple[int, int, int], 
    metric_value: float, 
    metric_name: str = "Contrast",
    width: int = 75
) -> str:
    """Format a header in the style: ┌─ {title} ───────────────────── (Code: {code}, Hex: {hex}, {metric}: {value})"""
    # Convert RGB to hex
    hex_color = rgb_to_hex(rgb[0], rgb[1], rgb[2])
    # Build metadata string (includes leading space)
    metadata = f" (Code: {color_code}, Hex: {hex_color}, {metric_name}: {metric_value:.2f})"
    # Calculate dashes needed to fill exactly to width
    # Total header width = "┌─ " (3) + title + " " (1) + dashes = width
    # So: dashes = width - 3 - len(title) - 1
    dashes_needed = width - 3 - len(title) - 1
    if dashes_needed < 0:
        dashes_needed = 0
    dashes = "─" * dashes_needed
    color_ansi = f"\x1B[38;5;{color_code}m"
    # Header is exactly width chars, metadata comes after
    return f"{color_ansi}┌─ {title} {dashes}{metadata}{COLOR_RESET}"


def main():
    """Main function to display headers and status messages."""
    if not HAS_PROMPT_TOOLKIT:
        print("Error: prompt_toolkit is required. Please install pyprompt dependencies.")
        return
    
    # First prompt: Select metric
    metric_key, metric_func, metric_name = prompt_metric_selection()
    
    if metric_key is None:
        print("Cancelled.")
        return
    
    # Determine if this is WCAG metric for special range options
    is_wcag = (metric_key == "wcag")
    
    # Prompt user for value range
    min_value, max_value, value_display = prompt_value_range(metric_name, metric_key, is_wcag)
    
    if min_value is None:
        print("Cancelled.")
        return
    
    # Find all colors with metric value in the selected range
    qualifying_colors = find_colors_with_metric(metric_func, min_value, max_value)
    
    if not qualifying_colors:
        print(f"\nNo colors found with {metric_name} {value_display} against #0C0D0E.")
        return
    
    print(f"\nFound {len(qualifying_colors)} colors with {metric_name} {value_display} against #0C0D0E")
    
    # Only prompt for color category if "all colors" was selected (min_value == 0.0 and max_value is None)
    if min_value == 0.0 and max_value is None:
        # Prompt user for color category
        selected_category = prompt_color_category()
        
        # Filter colors by selected category
        filtered_colors = filter_colors_by_category(qualifying_colors, selected_category)
        
        if not filtered_colors:
            print(f"\nNo colors found in the '{selected_category}' category with {metric_name} {value_display}.")
            return
        
        print(f"\nDisplaying {len(filtered_colors)} colors in the '{selected_category}' category:\n")
    else:
        # Use all qualifying colors (no category filter)
        filtered_colors = qualifying_colors
        print(f"\nDisplaying all {len(filtered_colors)} colors with {metric_name} {value_display}:\n")
    
    # Display headers in qualifying colors
    for code, rgb, metric_val in filtered_colors:
        header = format_header("Test Header", code, rgb, metric_val, metric_name)
        print(header)
        
        # Display formatted status messages
        # Info message: bold blue icon, no space, white text
        info_icon = f"{COLOR_BOLD}{COLOR_INFO}{ICON_INFO}{COLOR_RESET}"
        info_text = f"{COLOR_WHITE}Branch: main{COLOR_RESET}"
        print(f"  {info_icon}{info_text}")
        
        # Success message: green with space after icon
        print(f"  {COLOR_SUCCESS}{ICON_SUCCESS}{COLOR_RESET} SSH: Available and usable")
        
        # Warning message: yellow with space (no blank line above)
        print(f"  {COLOR_WARNING}{ICON_WARNING} Uncommitted changes{COLOR_RESET}")
        
        print()  # Blank line between color groups


if __name__ == '__main__':
    main()







# Metric Value Ranges (against #0C0D0E)
# WCAG Contrast Ratio
# Range: 1.03 to 19.45
# Average: 7.25
# Median: 5.70
# Typical range: 3.11–10.40 (25th–75th percentile)
# Notes: Standard accessibility metric; 4.5:1 is AA, 7:1 is AAA
# Delta E (CIE76)
# Range: 1.51 to 146.62 units
# Average: 85.22 units
# Median: 86.38 units
# Typical range: 67.37–106.42 units
# Notes: Simple color difference; higher = more different
# Delta E (CIE94)
# Range: 1.51 to 96.41 units
# Average: 57.11 units
# Median: 56.85 units
# Typical range: 39.63–74.80 units
# Notes: Improved over CIE76; accounts for chroma
# Delta E (CIEDE2000)
# Range: 1.51 to 96.41 units
# Average: 57.11 units
# Median: 56.85 units
# Typical range: 39.63–74.80 units
# Notes: Currently using CIE94 approximation; most accurate when fully implemented
# LAB Euclidean Distance
# Range: 1.51 to 146.62 units
# Average: 85.22 units
# Median: 86.38 units
# Typical range: 67.37–106.42 units
# Notes: Same as Delta E CIE76; perceptually uniform distance
# LCH Chroma Difference
# Range: 0.58 to 133.23 units
# Average: 58.07 units
# Median: 59.63 units
# Typical range: 33.09–86.49 units
# Notes: Measures saturation difference; ignores lightness
# Chromatic Contrast
# Range: 0.58 to 133.43 units
# Average: 58.62 units
# Median: 60.19 units
# Typical range: 33.32–86.80 units
# Notes: Color difference in ab plane; similar to LCH chroma
# Perceptual Contrast Score
# Range: 0.43 to 8.71
# Average: 3.81
# Median: 3.27
# Typical range: 2.14–5.08
# Notes: Combined metric (WCAG + Delta E + Chroma); normalized score
# Saturation Ratio
# Range: 0.00 to 567,856.12
# Average: 10,181.34
# Median: 124.26
# Typical range: 82.67–171.51
# Notes: Ratio of chroma values; can be very high when comparing saturated colors to near-black
# Recommendations for Custom Ranges:
# WCAG: Use standard ranges (3:1, 4.5:1, 7:1)
# Delta E variants: Try 30–80 for moderate distinction, 80+ for high distinction
# LAB/LCH/Chromatic: Similar to Delta E ranges
# Perceptual Score: Try 2–5 for moderate, 5+ for high
# Saturation Ratio: Use 50–200 for practical ranges (higher values are extreme)
# These ranges help set meaningful thresholds when using custom ranges for non-WCAG metrics.


