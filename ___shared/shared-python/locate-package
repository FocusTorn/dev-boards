#!/usr/bin/env python3
"""
Cross-platform script to locate Python packages in all possible locations.

Usage:
    python locate-package package1 package2 ...
    locate-package package1 package2 ...

Checks:
    - UV environment (if available)
    - Current Python's pip list (global + user site-packages)
    - User site-packages directory
    - Global site-packages directories
    - Virtual environments (if found)
"""

import sys
import os
import subprocess
import site
from pathlib import Path

# Color codes
COLOR_GREEN = "\x1B[32m"
COLOR_RED = "\x1B[31m"
COLOR_BLUE = "\x1B[38;5;33m"  # Same blue as git-py
COLOR_RESET = "\x1B[0m"
BOLD_CHECK = "✔"  # Unicode heavy/bold checkmark (U+2714)
CROSS = "✗"  # Unicode cross mark


def check_uv_environment(package_name):
    """Check if package is installed in UV environment."""
    try:
        result = subprocess.run(
            ["uv", "pip", "list"],
            capture_output=True,
            text=True,
            errors="ignore"
        )
        if result.returncode == 0:
            matches = [
                line for line in result.stdout.split("\n")
                if package_name.lower() in line.lower()
            ]
            return matches
    except (FileNotFoundError, subprocess.SubprocessError):
        pass
    return []


def check_pip_list(package_name):
    """Check if package is installed via pip (current Python environment)."""
    try:
        result = subprocess.run(
            [sys.executable, "-m", "pip", "list"],
            capture_output=True,
            text=True,
            errors="ignore"
        )
        if result.returncode == 0:
            matches = [
                line for line in result.stdout.split("\n")
                if package_name.lower() in line.lower()
            ]
            return matches
    except subprocess.SubprocessError:
        pass
    return []


def check_directory(package_name, directory):
    """Check if package directory exists in a site-packages directory."""
    if not directory or not os.path.exists(directory):
        return None
    
    # Check for package directory or .dist-info
    package_dirs = [
        os.path.join(directory, package_name),
        os.path.join(directory, package_name.replace("-", "_")),
    ]
    
    dist_info_patterns = [
        f"{package_name}-*.dist-info",
        f"{package_name.replace('-', '_')}-*.dist-info",
    ]
    
    found = []
    for pkg_dir in package_dirs:
        if os.path.exists(pkg_dir):
            found.append(f"Directory: {pkg_dir}")
    
    # Check for .dist-info directories
    try:
        import glob
        all_matches = []
        for pattern in dist_info_patterns:
            matches = glob.glob(os.path.join(directory, pattern))
            all_matches.extend(matches)
        # Remove duplicates
        all_matches = list(set(all_matches))
        if all_matches:
            found.extend([f"Dist-info: {m}" for m in all_matches])
    except Exception:
        pass
    
    return found if found else None


def check_user_site_packages(package_name):
    """Check user site-packages directory."""
    try:
        user_site = site.getusersitepackages()
        if user_site:
            return check_directory(package_name, user_site)
    except Exception:
        pass
    return None


def check_global_site_packages(package_name):
    """Check global site-packages directories."""
    found = []
    try:
        global_sites = site.getsitepackages()
        for site_dir in global_sites:
            result = check_directory(package_name, site_dir)
            if result:
                found.extend([f"{site_dir}: {r}" for r in result])
    except Exception:
        pass
    return found if found else None


def is_uv_managed_venv(venv_path):
    """Check if a venv is managed by UV."""
    venv_path = Path(venv_path)
    
    # Check pyvenv.cfg for UV indicators
    pyvenv_cfg = venv_path / "pyvenv.cfg"
    if pyvenv_cfg.exists():
        try:
            content = pyvenv_cfg.read_text()
            # UV-managed venvs often have specific markers
            if "uv" in content.lower() or "prompt" in content.lower():
                return True
        except Exception:
            pass
    
    # Check if .venv is in a directory with uv.lock or pyproject.toml with uv workspace
    parent = venv_path.parent
    if (parent / "uv.lock").exists() or (parent / "pyproject.toml").exists():
        try:
            if (parent / "pyproject.toml").exists():
                content = (parent / "pyproject.toml").read_text()
                if "[tool.uv" in content or "uv.workspace" in content:
                    return True
        except Exception:
            pass
    
    # Check if UV environment variable points to this venv
    uv_env = os.environ.get("UV_PROJECT_ENVIRONMENT")
    if uv_env and Path(uv_env).resolve() == venv_path.resolve():
        return True
    
    return False


def is_user_created_venv(venv_path):
    """Check if a venv is user-created (project venv)."""
    venv_path = Path(venv_path)
    
    # Common user-created venv names
    venv_name = venv_path.name.lower()
    if venv_name in [".venv", "venv", "env", "virtualenv"]:
        return True
    
    # Check if it's in a project directory (has common project files)
    parent = venv_path.parent
    project_indicators = [
        "pyproject.toml", "setup.py", "requirements.txt", 
        "Pipfile", "poetry.lock", ".git", "package.json"
    ]
    if any((parent / indicator).exists() for indicator in project_indicators):
        return True
    
    return False


def find_venvs():
    """Find virtual environments in common locations."""
    venvs = []
    
    # Check current directory and parent directories for .venv, venv, env
    current = Path.cwd()
    for path in [current] + list(current.parents)[:5]:  # Check up to 5 levels up
        for venv_name in [".venv", "venv", "env"]:
            venv_path = path / venv_name
            if venv_path.exists() and (venv_path / "pyvenv.cfg").exists():
                venvs.append(venv_path)
    
    # Check common venv locations
    home = Path.home()
    common_locations = [
        home / ".virtualenvs",
        home / ".venvs",
        Path.cwd() / ".venv",
        Path.cwd() / "venv",
        Path.cwd() / "env",
    ]
    
    for location in common_locations:
        if location.exists():
            if location.is_dir():
                # Check if it's a venv itself
                if (location / "pyvenv.cfg").exists():
                    if location not in venvs:
                        venvs.append(location)
                else:
                    # Check for venvs inside
                    for venv_dir in location.iterdir():
                        if venv_dir.is_dir() and (venv_dir / "pyvenv.cfg").exists():
                            if venv_dir not in venvs:
                                venvs.append(venv_dir)
    
    return venvs


def check_venv(package_name, venv_path):
    """Check if package is installed in a specific virtual environment."""
    venv_path = Path(venv_path)
    
    # Find site-packages in venv
    if sys.platform == "win32":
        site_packages = venv_path / "Lib" / "site-packages"
    else:
        # Try to find site-packages (could be in lib/pythonX.X/site-packages)
        site_packages = None
        lib_dir = venv_path / "lib"
        if lib_dir.exists():
            for python_dir in lib_dir.iterdir():
                if python_dir.is_dir() and python_dir.name.startswith("python"):
                    potential = python_dir / "site-packages"
                    if potential.exists():
                        site_packages = potential
                        break
    
    if site_packages and site_packages.exists():
        result = check_directory(package_name, str(site_packages))
        if result:
            # Add metadata about venv type
            return {
                "matches": result,
                "is_uv_managed": is_uv_managed_venv(venv_path),
                "is_user_created": is_user_created_venv(venv_path),
                "path": str(venv_path)
            }
    return None


def locate_package(package_name):
    """Locate a package in all possible locations."""
    results = {
        "uv": [],
        "pip": [],
        "user_site": None,
        "global_sites": None,
        "venvs": []
    }
    
    # Check UV environment
    results["uv"] = check_uv_environment(package_name)
    
    # Check pip list (current Python)
    results["pip"] = check_pip_list(package_name)
    
    # Check user site-packages
    results["user_site"] = check_user_site_packages(package_name)
    
    # Check global site-packages
    results["global_sites"] = check_global_site_packages(package_name)
    
    # Check virtual environments
    venvs = find_venvs()
    for venv in venvs:
        venv_result = check_venv(package_name, venv)
        if venv_result:
            results["venvs"].append(venv_result)
    
    return results


def write_header(title, width=70):
    """Create a header box for package name."""
    # Calculate dashes needed to fill width
    title_len = len(title)
    dashes_needed = width - title_len - 5  # 5 for "┌─ " and " ─"
    if dashes_needed < 0:
        dashes_needed = 0
    dashes = "─" * dashes_needed
    print(f"{COLOR_BLUE}┌─ {title} {dashes}{COLOR_RESET}")


def print_results(package_name, results):
    """Print formatted results for a package."""
    print()
    write_header(package_name)
    
    # Collect found and unfound items
    found_items = []
    unfound_items = []
    
    # UV Environment
    if results["uv"]:
        found_items.append(("UV Environment", results["uv"], None))
    else:
        unfound_items.append("UV Environment")
    
    # Virtual Environments - separate user-created from UV-managed
    user_venvs = [v for v in results["venvs"] if v.get("is_user_created") and not v.get("is_uv_managed")]
    uv_venvs = [v for v in results["venvs"] if v.get("is_uv_managed")]
    other_venvs = [v for v in results["venvs"] if not v.get("is_user_created") and not v.get("is_uv_managed")]
    
    if user_venvs:
        found_items.append(("User-Created Virtual Environments", None, user_venvs))
    if uv_venvs:
        found_items.append(("UV-Managed Virtual Environments", None, uv_venvs))
    if other_venvs:
        found_items.append(("Other Virtual Environments", None, other_venvs))
    
    if not results["venvs"]:
        unfound_items.append("Virtual Environments")
    
    # Pip List (Current Python)
    if results["pip"]:
        found_items.append(("Current Python (pip list)", results["pip"], None))
    else:
        unfound_items.append("Current Python (pip list)")
    
    # User Site-Packages
    if results["user_site"]:
        found_items.append(("User Site-Packages", results["user_site"], None))
    else:
        unfound_items.append("User Site-Packages")
    
    # Global Site-Packages
    if results["global_sites"]:
        found_items.append(("Global Site-Packages", results["global_sites"], None))
    else:
        unfound_items.append("Global Site-Packages")
    
    # Print found items first
    for title, matches, venvs in found_items:
        print(f"  {COLOR_GREEN}{BOLD_CHECK} {title}:{COLOR_RESET}")
        if matches:
            for match in matches:
                print(f"    - {match.strip()}")
        elif venvs:
            for venv_info in venvs:
                venv_path = venv_info.get("path", "Unknown")
                # Add type indicator
                type_indicator = ""
                if venv_info.get("is_uv_managed"):
                    type_indicator = " (UV-managed)"
                elif venv_info.get("is_user_created"):
                    type_indicator = " (user-created)"
                print(f"    - {venv_path}{type_indicator}:")
                for match in venv_info["matches"]:
                    # Keep the full match text (includes "Dist-info: " or "Directory: ")
                    match_text = match.strip()
                    print(f"      - {match_text}")
        print()
    
    # Print unfound items
    for title in unfound_items:
        print(f"  {COLOR_RED}{CROSS}{COLOR_RESET} {title}: (not found)")


def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        print("Usage: python locate-package package1 [package2 ...]")
        print("   or: locate-package package1 [package2 ...]")
        sys.exit(1)
    
    packages = sys.argv[1:]
    
    for package_name in packages:
        results = locate_package(package_name)
        print_results(package_name, results)
    
    print()


if __name__ == "__main__":
    main()

