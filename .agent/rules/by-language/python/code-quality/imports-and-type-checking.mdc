---
globs: **/*.py

---

# Imports and Type Checking Rules

## **CRITICAL EXECUTION DIRECTIVE**

**AI Agent Directive**: Follow imports and type checking rules exactly for all runtime import handling, type ignore usage, and type narrowing tasks.

**MANDATORY EXECUTION PROTOCOL**:

1. **NO DEVIATION**: All import and type checking rules must be followed exactly as written
2. **NO SKIPPING**: No steps may be skipped, abbreviated, or modified
3. **NO SELECTIVE COMPLIANCE**: All rules apply to all import and type checking activities
4. **FAILURE TO COMPLY**: Violating these rules constitutes a critical protocol violation

## **PREVENTIVE RULES** (What NOT to Do)

### **❌ NEVER Do These**

- ❌ **NEVER import before sys.path modification** - Always modify sys.path before importing local packages
- ❌ **NEVER skip type: ignore on runtime imports** - All imports resolved via sys.path MUST have `# type: ignore`
- ❌ **NEVER use pyright: ignore without approval** - `# pyright: ignore` is PROHIBITED unless explicitly approved
- ❌ **NEVER use module-level variables after None checks** - Assign to local variables for type narrowing
- ❌ **NEVER use process.stdout directly without None check** - Always check and assign to local variable first
- ❌ **NEVER skip individual symbol type ignore** - When importing from modules with runtime imports, add `# type: ignore[attr-defined]` to each symbol
- ❌ **NEVER call context manager __exit__ without None check** - Check both object and context manager before calling
- ❌ **NEVER return None when function returns int** - Return appropriate error codes instead
- ❌ **NEVER divide int parameters directly** - Convert to float before division operations
- ❌ **NEVER export functions without type annotations** - Helper modules MUST use `typing.cast` with proper `Callable` types
- ❌ **NEVER use local_imports when packages are installed** - Use direct imports from installed packages instead
- ❌ **NEVER skip linter configuration** - Always configure pyrightconfig.json or pyproject.toml for runtime imports

## **CORRECTIVE REFERENCE** (How to Fix When Errors Occur)

### **1. :: Runtime Imports with sys.path Modifications**

**When you see**: "Import could not be resolved" for local packages

**Follow this protocol**:

1. **Modify sys.path first**: Add package directory to sys.path before importing
2. **Add type: ignore**: Add `# type: ignore` to all imports resolved via sys.path
3. **Configure linter**: Set up pyrightconfig.json or pyproject.toml with executionEnvironments

**✅ CORRECT - Scripts that modify sys.path before importing local packages**:

```python
import sys
from pathlib import Path

# Add parent directory to path so lib package can be imported
_SCRIPT_DIR = Path(__file__).parent
_PROJECT_DIR = _SCRIPT_DIR.parent  # scripts -> project-root
sys.path.insert(0, str(_PROJECT_DIR))

# Now imports work at runtime
from lib.config import load_config  # type: ignore
from lib.output import print_info  # type: ignore
```

**✅ CORRECT - Optional local packages with fallback**:

```python
# Try to import local package with fallback
try:
    # Add shared-python to path
    _current_file = Path(__file__)
    _project_dir = _current_file.parent.parent
    _shared_dir = _project_dir.parent
    _shared_python = _shared_dir / 'shared-python'
    
    if _shared_python.exists():
        sys.path.insert(0, str(_shared_python))
        _pyprompt_dir = _shared_python / 'pyprompt'
        if _pyprompt_dir.exists():
            sys.path.insert(0, str(_pyprompt_dir))
    
    from pyprompt import select as pyprompt_select  # type: ignore
    HAS_PYPROMPT = True
except ImportError:
    HAS_PYPROMPT = False
    pyprompt_select = None
```

**❌ INCORRECT - Missing type: ignore comments**:

```python
# Wrong: Linter will show warnings for imports resolved at runtime
from lib.config import load_config  # Missing # type: ignore
from pyprompt import select  # Missing # type: ignore
```

**❌ INCORRECT - Imports before sys.path modification**:

```python
# Wrong: Import before sys.path is modified
from lib.config import load_config  # Will fail at runtime

import sys
from pathlib import Path
_SCRIPT_DIR = Path(__file__).parent
sys.path.insert(0, str(_SCRIPT_DIR.parent))
```

### **2. :: Linter Configuration**

**When you see**: Type checker warnings for runtime imports even with `# type: ignore`

**Follow this protocol**:

1. **Check configuration exists**: Verify pyrightconfig.json or pyproject.toml has executionEnvironments
2. **Verify root matches script location**: Root should match directory containing the script
3. **Check extraPaths**: Ensure all runtime paths are included in extraPaths
4. **Set reportMissingImports**: Set to "none" to suppress warnings for runtime imports

**✅ CORRECT - pyproject.toml configuration for CursorPyright**:

```toml
[tool.basedpyright]
# OR [tool.pyright] - both work with CursorPyright
# CursorPyright uses BasedPyright internally, so [tool.basedpyright] is preferred
include = ["scripts", "lib", "tests"]
exclude = ["**/__pycache__", "**/_removed", ".uv"]
executionEnvironments = [
    { 
      root = "scripts", 
      extraPaths = [
        "..",
        "../../shared-python",
        "../../shared-python/pyprompt",
        "../../shared-python/indeneder"
      ] 
    }
]
pythonVersion = "3.11"
typeCheckingMode = "basic"
reportMissingImports = "none"
reportMissingTypeStubs = false
```

**Note**: CursorPyright is native to Cursor and automatically reads `[tool.basedpyright]` or `[tool.pyright]` sections from `pyproject.toml`.

**❌ INCORRECT - Missing linter configuration**:

```python
# Wrong: No pyrightconfig.json or pyproject.toml configuration
# Linter will show warnings for all runtime imports
from lib.config import load_config  # Shows warning
```

**❌ INCORRECT - Wrong execution environment root**:

```json
{
  "executionEnvironments": [
    {
      "root": ".",  // Wrong: Should be "scripts" for files in scripts/
      "extraPaths": [".."]
    }
  ]
}
```

### **3. :: Type Ignore Comments**

**When you see**: Type checker warnings for imports that work at runtime

**Follow this protocol**:

1. **Verify it's a runtime import**: Confirm import is resolved via sys.path modification
2. **Add type: ignore on import line**: Place `# type: ignore` on the same line as the import
3. **For nested dependencies**: Add `# type: ignore[attr-defined]` to each individual symbol
4. **Request user approval**: Get explicit approval before adding type ignore comments

**✅ CORRECT - Direct runtime imports**:

```python
# Imports that are resolved at runtime via sys.path modifications
from lib.config import load_config  # type: ignore
from lib.output import (  # type: ignore
    print_error, print_success, print_warning
)
from lib.sync_ops import sync_package_mapping  # type: ignore
from pyprompt import select as pyprompt_select  # type: ignore
```

**✅ CORRECT - Indirect runtime imports**:

```python
# Helper module (local_imports.py) internally modifies sys.path to load packages
from local_imports import (  # type: ignore
    write_header,
    error,
    warning,
    text,
    select,
)
```

**❌ INCORRECT - Type ignore on wrong line**:

```python
# Wrong: type: ignore must be on the import line
from lib.config import load_config
# type: ignore  # Wrong: Must be on same line as import
```

**❌ INCORRECT - Missing type: ignore for runtime imports**:

```python
# Wrong: Missing type: ignore - linter will show warnings
from lib.config import load_config
from pyprompt import select
```

#### **3.3. :: User Approval Requirement**

**CRITICAL - User Approval Required for Type Ignore Comments**: The AI agent MUST NOT add `# type: ignore` comments without explicit user approval. When type checker errors appear, the AI agent MUST: (1) investigate the root cause (package structure, type checker configuration, import chains), (2) verify runtime behavior, (3) propose solutions to the user, and (4) only add type ignore comments after receiving explicit approval. Type ignore comments are workarounds that suppress warnings and should only be used when necessary and approved.

**When you see**: Type checker errors that might require `# type: ignore`

**Follow this protocol**:

1. **Investigate root cause**: Check package structure, type checker configuration, and import chains
2. **Verify runtime behavior**: Test that imports work at runtime
3. **Propose solutions**: Present findings and proposed solutions to the user
4. **Request explicit approval**: Only add `# type: ignore` after receiving explicit user approval

**✅ CORRECT - Investigation before proposing type ignore**:

```python
# Error: "Import 'outerm.palette' could not be resolved"

# Step 1: Investigate root cause
# - Check package structure: Has __init__.py? ✓
# - Check relative imports: Proper structure? ✓
# - Test runtime import: Works at runtime? ✓
# - Check type checker config: extraPaths configured? Check pyproject.toml

# Step 2: Verify runtime behavior
import outerm.palette  # ✓ Works at runtime

# Step 3: Propose solution to user
# "Package structure is correct and runtime imports work. 
#  Type checker configuration may need extraPaths update, 
#  or this may be a false positive requiring type: ignore. 
#  Should I add type: ignore after confirming config?"

# Step 4: Only add type: ignore after explicit user approval
from outerm.palette import Palette  # type: ignore  # Added after user approval
```

**❌ INCORRECT - Adding type ignore without investigation and approval**:

```python
# Wrong: Adding type: ignore immediately without investigation
from outerm.palette import Palette  # type: ignore  # Don't do this without approval

# Wrong: Not verifying runtime behavior first
# Should test: import outerm.palette  # Does this work?

# Wrong: Not checking type checker configuration
# Should check: pyproject.toml for [tool.basedpyright] extraPaths
```

**❌ INCORRECT - Adding type ignore without user approval**:

```python
# Wrong: AI agent adding type: ignore automatically
# AI agent must request approval first:
# "I found a type checker error. After investigation, I recommend adding 
#  # type: ignore. May I proceed?"

# Only add after user explicitly approves
```

### **4. :: pyright: ignore Comments Are Prohibited**

**When you see**: Type checker errors that might tempt you to use `# pyright: ignore`

**Follow this protocol**:

1. **Investigate root cause**: Check if error can be fixed with proper type narrowing or annotations
2. **Use type narrowing**: Apply type narrowing patterns instead of suppression
3. **Request approval if needed**: Only use `# pyright: ignore` if explicitly approved by user

**✅ CORRECT - Use proper type narrowing instead of pyright: ignore**:

```python
# Correct: Use type narrowing to fix type errors
from outerm import write_header as _write_header_import
if _write_header_import is None:
    raise ImportError("write_header must be available")
write_header: Callable[..., Any] = cast(Callable[..., Any], _write_header_import)
```

**❌ INCORRECT - Using pyright: ignore without approval**:

```python
# Wrong: Using pyright: ignore without explicit approval
print(warning('', "Message"))  # pyright: ignore[reportOptionalCall]  # Don't do this

# Wrong: Suppressing type errors instead of fixing them
result = some_function()  # pyright: ignore  # Don't do this
```

### **5. :: Type Narrowing for Optional Imports**

**When you see**: "Object of type 'None' cannot be called" for conditionally imported objects

**Follow this protocol**:

1. **Check for None first**: Always check if the object is `None` before using
2. **Raise error if None**: If the object is `None`, raise `ImportError` with a clear message
3. **Assign to local variable**: Assign the checked object to a local variable (prefixed with `_`)
4. **Use local variable throughout**: Use the local variable instead of the module-level variable

**✅ CORRECT - Use type narrowing by assigning to local variables after None checks**:

```python
# Module-level conditional import
try:
    from prompt_toolkit.formatted_text import FormattedText
    from prompt_toolkit.layout import Layout
    HAS_PROMPT_TOOLKIT = True
except ImportError:
    HAS_PROMPT_TOOLKIT = False
    FormattedText = None
    Layout = None

def my_function():
    # Check and narrow types at function entry
    if FormattedText is None:
        raise ImportError("prompt_toolkit.formatted_text.FormattedText is required")
    _FormattedText = FormattedText  # Type checker knows this is not None
    
    if Layout is None:
        raise ImportError("prompt_toolkit.layout.Layout is required")
    _Layout = Layout  # Type checker knows this is not None
    
    # Now use the local variables - no type errors
    formatted = _FormattedText([('class:text', 'Hello')])
    layout = _Layout(container)
    
    return formatted
```

**❌ INCORRECT - Using module-level variables directly after None checks**:

```python
def my_function():
    if FormattedText is None:
        raise ImportError("FormattedText is required")
    
    # Wrong: Type checker still thinks FormattedText could be None
    return FormattedText([])  # Error: "Object of type 'None' cannot be called"
```

**❌ INCORRECT - Using type: ignore instead of proper type narrowing**:

```python
def my_function():
    if FormattedText is None:
        raise ImportError("FormattedText is required")
    
    # Wrong: Suppressing type checking instead of fixing the root cause
    return FormattedText([])  # type: ignore[misc]  # Don't do this
```

### **6. :: Optional Member Access for Process Objects**

**When you see**: "'readline' is not a known attribute of 'None'" for process.stdout

**Follow this protocol**:

1. **Check for None**: Always check `process.stdout` for None before using
2. **Assign to local variable**: Assign to local variable for type narrowing
3. **Use local variable**: Use the local variable instead of `process.stdout` directly

**✅ CORRECT - Check for None and assign to local variable before use**:

```python
process = subprocess.Popen(
    ["command"],
    stdout=subprocess.PIPE,
    stderr=subprocess.STDOUT,
    text=True
)

# Check and assign to local variable for type narrowing
stdout = process.stdout
if stdout is None:
    break  # or handle error appropriately

# Now use the local variable - type checker knows it's not None
remaining = stdout.read()
line = stdout.readline()
```

**❌ INCORRECT - Using process.stdout directly without check**:

```python
process = subprocess.Popen([...], stdout=subprocess.PIPE)

# Wrong: Type checker thinks stdout could be None
remaining = process.stdout.read()  # Type error
```

### **7. :: Runtime Imports with Nested Dependencies**

**When you see**: "unknown import symbol" for individual symbols from modules with runtime imports

**Follow this protocol**:

1. **Add type: ignore on import line**: Add `# type: ignore` to the import statement
2. **Add attr-defined to each symbol**: Add `# type: ignore[attr-defined]` to each individual symbol

**✅ CORRECT - Add type: ignore[attr-defined] to each individual symbol**:

```python
from .interface import (  # type: ignore
    show_interactive_menu,
    print_help,
    action,  # type: ignore[attr-defined]
    success,  # type: ignore[attr-defined]
    error,  # type: ignore[attr-defined]
    warning,  # type: ignore[attr-defined]
    info,  # type: ignore[attr-defined]
    write_header,  # type: ignore[attr-defined]
    write_header_fat,  # type: ignore[attr-defined]
    write_boxed_header,  # type: ignore[attr-defined]
)
```

**❌ INCORRECT - Only type: ignore on import line**:

```python
# Wrong: Type checker still can't resolve individual symbols
from .interface import (  # type: ignore
    action,  # Still shows error
    success,  # Still shows error
    error,  # Still shows error
)
```

### **8. :: Context Manager Optional Access**

**When you see**: "'__exit__' is not a known attribute of 'None'" for context managers

**Follow this protocol**:

1. **Check both object and context manager**: Check both the object (e.g., `current_bar`) and context manager (e.g., `current_bar_cm`)
2. **Use type narrowing**: Assign to local variable after None check if needed

**✅ CORRECT - Check both the object and context manager before calling __exit__**:

```python
current_bar = None
current_bar_cm = None

# ... later ...

if current_bar and current_bar_cm is not None:
    current_bar_cm.__exit__(None, None, None)
    current_bar = None
    current_bar_cm = None
```

**❌ INCORRECT - Only checking the object, not the context manager**:

```python
# Wrong: Only checking current_bar, not current_bar_cm
if current_bar:
    current_bar_cm.__exit__(None, None, None)  # Type error
```

### **9. :: Return Type Consistency**

**When you see**: "Type 'None' is not assignable to return type 'int'"

**Follow this protocol**:

1. **Return appropriate error codes**: Return error codes (e.g., `1`) instead of `None` for functions that return `int`
2. **Ensure all paths return**: Make sure all code paths return the declared type

**✅ CORRECT - Return appropriate error codes**:

```python
def upload_sketch(config: PmakeConfig) -> int:
    process = subprocess.Popen(...)
    stdout = process.stdout
    if stdout is None:
        return 1  # Return error code instead of None
    # ...
    return 0  # Return success code
```

**❌ INCORRECT - Returning None when function returns int**:

```python
# Wrong: Function returns int but returning None
def process() -> int:
    if error_condition:
        return  # Type error: None not assignable to int
    return 0
```

### **10. :: Type Conversion for Division Operations**

**When you see**: "Type 'float' is not assignable to declared type 'int'" in division operations

**Follow this protocol**:

1. **Convert to float before division**: Convert `int` parameters to `float` before division
2. **Use separate variable**: Use a separate variable for calculations

**✅ CORRECT - Convert to float before division**:

```python
def format_size(size_bytes: int) -> str:
    size: float = float(size_bytes)  # Convert to float for division
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size < 1024.0:
            return f"{size:.1f} {unit}"
        size /= 1024.0
    return f"{size:.1f} TB"
```

**❌ INCORRECT - Dividing int parameter directly**:

```python
# Wrong: Dividing int parameter causes type error
def format_size(size_bytes: int) -> str:
    size_bytes /= 1024.0  # Type error: float not assignable to int
```

### **11. :: Helper Modules with Runtime Imports**

**When you see**: "reportOptionalCall" errors for functions from helper modules

**Follow this protocol**:

1. **Use typing.cast with Callable types**: Export functions with proper `Callable` type annotations
2. **Raise errors instead of None**: If module isn't available, raise `ImportError` instead of setting to `None`
3. **Match function signatures**: Ensure `Callable` type definitions match actual function signatures

**✅ CORRECT - Use typing.cast with proper Callable types**:

```python
from typing import Callable, Optional, cast
from contextlib import AbstractContextManager

# Define type aliases for exported functions
_SuccessType = Callable[[str, str], str]
_WriteHeaderFatType = Callable[[str, Optional[int], bool, bool, bool], Optional[AbstractContextManager[None]]]

# Export outerm functions and classes
if _outerm_module is not None:
    # Use cast to tell type checker the correct types
    success = cast(_SuccessType, getattr(_outerm_module, 'success', None))
    write_header_fat = cast(_WriteHeaderFatType, getattr(_outerm_module, 'write_header_fat', None))
else:
    success = None
    write_header_fat = None
```

**❌ INCORRECT - Using getattr without cast**:

```python
# Wrong: Type checker thinks these could be None or Any
success = getattr(_outerm_module, 'success', None)  # Type: Optional[Any]
write_header_fat = getattr(_outerm_module, 'write_header_fat', None)  # Type: Optional[Any]
```

### **12. :: Direct Imports from Installed Packages**

**When you see**: Using `local_imports` when packages are installed with `-e`

**Follow this protocol**:

1. **Use direct imports**: Import directly from installed packages
2. **Remove sys.path modifications**: Remove unnecessary sys.path manipulation
3. **Remove type ignore**: Direct imports don't need `# type: ignore`
4. **Remove runtime checks**: Direct imports don't need None checks or assertions

**✅ CORRECT - Use direct imports from installed packages**:

```python
# Packages are installed with -e or regular installation
from outerm import error, warning, info, success, write_header, write_header_fat
from pyprompt import select, confirm, text

# No type: ignore needed - these are proper imports
# No runtime checks needed - packages are guaranteed to exist
print(error('Error message', ''))
selected = select("Choose:", choices=choices)
```

**❌ INCORRECT - Using local_imports when packages are installed**:

```python
# Wrong: Using local_imports when packages are installed
import sys
from pathlib import Path

_workspace_root = Path(os.environ.get('WORKSPACE_ROOT'))
_shared_python_dir = _workspace_root / "___shared" / "shared-python"
if str(_shared_python_dir) not in sys.path:
    sys.path.insert(0, str(_shared_python_dir))

from local_imports import error, warning, info, success  # type: ignore

# Type checker reports: Object of type "None" cannot be called
print(error('Error message', ''))  # Error: reportOptionalCall
```

## **ANTI-PATTERNS**

### **❌ Runtime Import Violations**

- ❌ **Missing Type Ignore** - Don't skip `# type: ignore` on imports resolved via sys.path
- ❌ **Imports Before Path Setup** - Don't import local packages before modifying sys.path
- ❌ **Missing Linter Config** - Don't skip pyrightconfig.json or pyproject.toml configuration
- ❌ **Wrong Execution Environment** - Don't use wrong root in executionEnvironments
- ❌ **Ignoring Pre-Existing Errors** - Don't skip fixing linting errors because they existed before current changes
- ❌ **Adding Type Ignore Without Approval** - Don't add `# type: ignore` comments without explicit user approval after investigation

### **❌ pyright: ignore Violations**

- ❌ **Using pyright: ignore Without Approval** - Don't use `# pyright: ignore` or `# pyright: ignore[...]` unless explicitly approved by user or project maintainer
- ❌ **Suppressing Instead of Fixing** - Don't use `# pyright: ignore` to suppress type errors - fix them with proper type narrowing or type annotations
- ❌ **pyright: ignore as First Solution** - Don't use `# pyright: ignore` as the first solution to type errors - investigate root causes first

### **❌ Type Narrowing Violations**

- ❌ **Using Module-Level Variables After None Checks** - Don't use module-level variables directly after None checks - assign to local variables for type narrowing
- ❌ **Using type: ignore Instead of Type Narrowing** - Don't suppress type checking with `# type: ignore` - use proper type narrowing instead
- ❌ **Missing None Checks** - Don't use conditionally imported objects without checking for None first
- ❌ **Not Assigning to Local Variables** - Don't check for None but continue using the module-level variable - assign to local variable after check

### **❌ Process Object Violations**

- ❌ **Using process.stdout Directly** - Don't use `process.stdout` directly without checking for None first
- ❌ **Assuming stdout is Always Available** - Don't assume `process.stdout` is not None even when `stdout=subprocess.PIPE` is set
- ❌ **Using type: ignore for Process Objects** - Don't suppress type checking for process.stdout - use proper None checks instead

### **❌ Runtime Import Nested Dependency Violations**

- ❌ **Missing Individual Symbol Type Ignore** - Don't skip `# type: ignore[attr-defined]` on individual symbols when importing from modules with runtime imports
- ❌ **Only Type Ignore on Import Line** - Don't rely solely on `# type: ignore` on the import line for nested runtime imports
- ❌ **Missing attr-defined Error Code** - Don't use generic `# type: ignore` when `# type: ignore[attr-defined]` is more specific

### **❌ Context Manager Violations**

- ❌ **Calling __exit__ Without None Check** - Don't call `__exit__()` on context managers that could be None without checking first
- ❌ **Only Checking Object, Not Context Manager** - Don't only check the object (e.g., `current_bar`) without also checking the context manager (e.g., `current_bar_cm`)
- ❌ **Using type: ignore for Context Managers** - Don't suppress type checking for context manager access - use proper None checks instead

### **❌ Return Type Violations**

- ❌ **Returning None When Function Returns int** - Don't return `None` or use bare `return` when function is declared to return `int`
- ❌ **Missing Return Statements** - Don't have code paths without return statements when function is declared to return a value
- ❌ **Inconsistent Return Types** - Don't return different types than declared in function signature

### **❌ Type Conversion Violations**

- ❌ **Dividing int Parameters Directly** - Don't divide `int` parameters directly - convert to `float` first
- ❌ **Reassigning int to float** - Don't reassign `int` parameters with float values - use separate variables
- ❌ **Using type: ignore for Type Conversions** - Don't suppress type checking for division operations - use proper type conversion instead

### **❌ Helper Module Violations**

- ❌ **No Type Annotations** - Don't export functions from helper modules without proper `Callable` type annotations
- ❌ **Missing typing.cast** - Don't use `getattr` without `typing.cast` to properly type exported functions
- ❌ **Setting Functions to None** - Don't set exported functions to `None` without type annotations (causes `reportOptionalCall` errors)
- ❌ **Using getattr with None Default** - Don't use `getattr(module, 'func', None)` without `typing.cast` or type annotations

### **❌ Direct Import Violations**

- ❌ **Using local_imports When Packages Are Installed** - Don't use `local_imports` when packages are installed with `-e` or regular installation - use direct imports instead
- ❌ **Unnecessary sys.path Manipulation** - Don't modify `sys.path` when packages are properly installed - Python can find them automatically
- ❌ **Type Ignore on Direct Imports** - Don't add `# type: ignore` to direct imports from installed packages - they don't need it
- ❌ **Runtime Checks for Installed Packages** - Don't add None checks or assertions for direct imports from installed packages - they're guaranteed to exist

## **QUALITY GATES**

- [ ] **Type Ignore Comments**: All runtime imports have `# type: ignore` comments (only after user approval)
- [ ] **User Approval for Type Ignore**: All `# type: ignore` comments added only after explicit user approval following investigation
- [ ] **No pyright: ignore Without Approval**: No `# pyright: ignore` comments used unless explicitly approved
- [ ] **Path Setup Before Imports**: sys.path modifications occur before importing local packages
- [ ] **Linter Configuration**: pyrightconfig.json or pyproject.toml has executionEnvironments configured
- [ ] **Correct Root**: executionEnvironments root matches the directory containing the script
- [ ] **Extra Paths**: All runtime paths are included in extraPaths
- [ ] **Report Missing Imports**: Set to "none" to suppress warnings for runtime imports
- [ ] **Pre-Existing Error Remediation**: All detected linting errors (including pre-existing ones) have been remediated
- [ ] **Type Narrowing Applied**: Conditionally imported objects are assigned to local variables after None checks for proper type narrowing
- [ ] **No Optional Member Access Errors**: All uses of conditionally imported objects use narrowed local variables, not module-level variables
- [ ] **No type: ignore Suppression**: Type errors are fixed with proper type narrowing, not suppressed with `# type: ignore` comments
- [ ] **Process stdout Checks**: All uses of `process.stdout` check for None and assign to local variable before use
- [ ] **Nested Runtime Import Symbols**: Individual symbols from modules with runtime imports have `# type: ignore[attr-defined]` comments
- [ ] **Context Manager None Checks**: Context manager `__exit__()` calls check that the context manager is not None before calling
- [ ] **Return Type Consistency**: All return statements match the declared return type (e.g., return `int` not `None` for `-> int` functions)
- [ ] **Type Conversion for Division**: `int` parameters are converted to `float` before division operations
- [ ] **Helper Module Type Annotations**: Helper modules that export functions use proper `Callable` type annotations with `typing.cast`
- [ ] **Proper Callable Signatures**: `Callable` type definitions match actual function signatures
- [ ] **Context Manager Types**: Functions returning context managers use `Optional[AbstractContextManager[None]]`
- [ ] **No Optional Call Errors**: Helper modules don't require consumers to add `# type: ignore[reportOptionalCall]` comments
- [ ] **Error Handling**: Helper modules raise `ImportError` instead of setting functions to `None` when modules aren't available
- [ ] **Direct Imports for Installed Packages**: When packages are installed with `-e` or regular installation, use direct imports instead of `local_imports`
- [ ] **No Unnecessary sys.path Manipulation**: Removed `sys.path` modifications when packages are properly installed
- [ ] **No Type Ignore on Direct Imports**: Direct imports from installed packages don't have unnecessary `# type: ignore` comments
- [ ] **No Runtime Checks for Installed Packages**: Direct imports from installed packages don't have unnecessary None checks or assertions

## **SUCCESS METRICS**

After implementing proper imports and type checking:

- ✅ **No Linter Warnings** - All runtime imports properly configured
- ✅ **Clean Code** - Type ignore comments clearly mark runtime imports (only after approval)
- ✅ **Proper Configuration** - Linter understands runtime path modifications
- ✅ **Maintainable** - Future developers understand why type: ignore is needed
- ✅ **User Approval Obtained** - All type ignore comments added only after explicit user approval following investigation
- ✅ **No Optional Member Access Errors** - Type narrowing prevents `reportOptionalMemberAccess` and `reportOptionalCall` errors
- ✅ **Proper Type Narrowing** - Conditionally imported objects are properly narrowed using local variables
- ✅ **No Type Suppression** - Type errors are fixed properly, not suppressed with `# type: ignore` comments
- ✅ **Process Objects Handled Correctly** - `process.stdout` and similar optional attributes are properly checked before use
- ✅ **Nested Runtime Imports Resolved** - Individual symbols from modules with runtime imports are properly handled with `# type: ignore[attr-defined]`
- ✅ **Context Managers Safely Accessed** - Context manager `__exit__()` calls are properly guarded with None checks
- ✅ **Return Types Consistent** - All return statements match declared return types
- ✅ **Type Conversions Proper** - Division operations properly convert `int` to `float` before calculation
- ✅ **No Optional Call Errors** - Helper modules provide proper type annotations with `typing.cast`, preventing `reportOptionalCall` errors
- ✅ **Clean Consumer Code** - Consumers don't need runtime assertions or `# type: ignore[reportOptionalCall]` comments
- ✅ **Type Safety** - Type checker correctly infers function types from helper modules
- ✅ **Proper Context Manager Types** - Context manager return types are correctly typed as `Optional[AbstractContextManager[None]]`
- ✅ **Accurate Callable Signatures** - `Callable` type definitions match actual function signatures

## **EXECUTION PRIORITY MATRIX**

### **CRITICAL PRIORITY (Execute immediately)**

- Add `# type: ignore` to all imports resolved via sys.path modifications
- Configure pyrightconfig.json or pyproject.toml with executionEnvironments
- Ensure sys.path modifications occur before imports
- **Type narrowing for optional imports** - When using conditionally imported objects, assign to local variables after None checks for proper type narrowing
- **Nested runtime import symbols** - When importing from modules with runtime imports, add `# type: ignore[attr-defined]` to each individual symbol
- **Context manager None checks** - When calling `__exit__()` on context managers, check both the object and context manager are not None
- **Return type consistency** - Ensure all return statements match the declared return type (return error codes, not None, for `-> int` functions)
- **Type conversion for division** - Convert `int` parameters to `float` before division operations
- **Helper module type annotations** - When creating helper modules that export functions, use `typing.cast` with proper `Callable` type annotations
- **Direct imports for installed packages** - When packages are installed with `-e` or regular installation, use direct imports instead of `local_imports`

### **HIGH PRIORITY (Execute before proceeding)**

- Verify linter configuration is correct for script location
- Test that imports work at runtime
- Verify linter warnings are suppressed

### **MEDIUM PRIORITY (Execute during normal operation)**

- Document why type: ignore is needed in code comments
- Keep linter configuration up to date as paths change

## **DYNAMIC MANAGEMENT NOTE**

This document is optimized for AI agent internal processing and may be updated dynamically based on operational needs and pattern recognition. The structure prioritizes AI agent compliance and effectiveness over traditional documentation practices.
