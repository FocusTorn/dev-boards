---
alwaysApply: true
---

p

# Workflow Rules

## **CRITICAL EXECUTION DIRECTIVE**

**AI Agent Directive**: Follow workflow rules exactly for all coding tasks to ensure proper rule discovery and compliance.

**MANDATORY EXECUTION PROTOCOL**:

1. **PROACTIVE RULE DISCOVERY**: Before starting ANY task, MUST check for relevant rule files in `.cursor/rules/` directory structure
2. **NO DEVIATION**: All workflow rules must be followed exactly as written
3. **NO SKIPPING**: No steps may be skipped, abbreviated, or modified
4. **NO SELECTIVE COMPLIANCE**: All rules apply to all coding activities
5. **FAILURE TO COMPLY**: Violating these rules constitutes a critical protocol violation

## **RULE DISCOVERY PROTOCOL**

### **1. :: Mandatory Pre-Task Rule Discovery**

**CRITICAL ENFORCEMENT - MANDATORY FIRST ACTION**: Rule discovery is NOT optional. It is the FIRST action that MUST be executed before ANY code changes, file edits, or task execution. The AI agent MUST explicitly perform and document rule discovery as the first step of every task.

**✅ CORRECT - Mandatory rule discovery protocol (MUST execute in this order)**:

**STEP 1 - Identify Task Category** (MANDATORY FIRST STEP):
   - Determine what type of task you're working on
   - Language-specific (Python, JavaScript,Rust, etc.) → Check `.cursor/rules/by-language/[language]/`
   - **Python tasks**: MUST check `.cursor/rules/by-language/python/code-quality/` directory (all category files)
   - **Rust tasks**: **CRITICAL ENFORCEMENT** - MUST explicitly read `.cursor/rules/by-language/rust/build-and-test.mdc` BEFORE making any code changes. After making Rust code changes, MUST run `cargo build`, fix ALL warnings, and verify the build succeeds with zero warnings before marking the task complete. This verification is MANDATORY and cannot be skipped.
   - Tool-specific (UV, etc.) → Check `.cursor/rules/tool/[tool]/`
   - Formatting (markdown, terminal output, etc.) → Check `.cursor/rules/formatting/`
   - Code quality/linter → Check `.cursor/rules/by-language/[language]/code-quality/` directory
   - Code maintenance/refactoring → Already loaded (universal rule)
   - Documentation → Check `.cursor/rules/documentation.mdc` (universal rule)
   - Project-specific → Check `.cursor/rules/dev-boards/` or other project directories

**STEP 2 - Discover and List Rule Files** (MANDATORY SECOND STEP):
   - Use `glob_file_search` or `list_dir` to search for and list ALL rule files that might apply
   - For Python tasks: MUST list all files in `.cursor/rules/by-language/python/` directory
   - Document the discovered rule files explicitly in your response
   - **VERIFICATION**: You must be able to list the rule files you found before proceeding

**STEP 3 - Read Rule Files** (MANDATORY THIRD STEP):
   - Read ALL relevant rule files BEFORE making any changes
   - Use `read_file` tool to read each discovered rule file
   - **VERIFICATION**: You must have read the rule files before proceeding to step 4

**STEP 4 - Document Rule Discovery** (MANDATORY FOURTH STEP):
   - Explicitly state which rule files were discovered and read
   - List the key rules that apply to the current task
   - **VERIFICATION**: Document rule discovery in your response before proceeding

**STEP 5 - Apply Rules** (ONLY AFTER STEPS 1-4 COMPLETE):
   - Apply rules from the start, not after errors appear
   - Reference specific rules when making decisions
   - **VERIFICATION**: Rules must be applied proactively, not reactively

**MANDATORY VERIFICATION CHECKPOINT**: Before making ANY code changes, the AI agent MUST be able to answer:
- "What rule files did I discover for this task?"
- "Which rule files did I read?"
- "What are the key rules that apply to this task?"
- "How will I apply these rules?"

If these questions cannot be answered, rule discovery is INCOMPLETE and the task MUST NOT proceed.

**❌ INCORRECT - Starting task without rule discovery**:

1. Start making code changes immediately
2. Only check rules after errors appear
3. Assume rules don't exist or aren't relevant
4. Skip rule discovery step
5. **CRITICAL VIOLATION**: Proceeding to code changes without explicitly performing and documenting rule discovery steps 1-4 above

**NATURAL STOP - Rule Discovery Verification**:

Before proceeding with ANY code changes, the AI agent MUST encounter a natural stop that requires explicit rule discovery verification. This natural stop is triggered by:

- **File Edit Attempt**: Any attempt to edit a file MUST be preceded by documented rule discovery
- **Code Change Request**: Any request to change code MUST be preceded by documented rule discovery
- **Task Execution**: Any task execution MUST be preceded by documented rule discovery

**VERIFICATION PROTOCOL**: The AI agent MUST explicitly state in the response:
1. "I have discovered the following rule files: [list]"
2. "I have read the following rule files: [list]"
3. "The key rules that apply to this task are: [list]"
4. "I will apply these rules by: [explanation]"

Only after this verification is explicitly stated can the task proceed.

### **2. :: Rule Discovery Checklist**

**REQUIRED PRE-TASK CHECKLIST** (MUST be completed and verified before ANY code changes):

- [ ] **Task Category Identified**: Determined what type of task this is (language, tool, formatting, etc.)
- [ ] **Rule Files Discovered**: Used `glob_file_search` or `list_dir` to discover ALL relevant rule files
- [ ] **Rule Files Listed**: Explicitly listed discovered rule files in response
- [ ] **Rule Files Read**: Used `read_file` to read ALL relevant rule files before starting
- [ ] **Rule Discovery Documented**: Explicitly stated which rules were discovered and read
- [ ] **Key Rules Identified**: Listed the key rules that apply to the current task
- [ ] **Code Quality Rules Checked**: For Python tasks, checked `.cursor/rules/by-language/python/code-quality/` directory (all category files)
- [ ] **Rules Applied**: Applied rules from the start, not reactively after errors
- [ ] **Verification Complete**: Can answer "What rules did I discover?" and "What rules did I read?" before proceeding

**MANDATORY VERIFICATION**: The checklist above MUST be completed and explicitly verified in the AI agent's response before making ANY code changes. Skipping this verification constitutes a CRITICAL PROTOCOL VIOLATION.

### **3. :: Rule File Locations**

**Language-Specific Rules**:
- `.cursor/rules/by-language/[language]/` - Check for relevant rule files based on file type
- **Python tasks**: MUST check `.cursor/rules/by-language/python/` directory structure:
  - `.cursor/rules/by-language/python/code-quality/` (all category files: index.mdc, error-investigation.mdc, imports-and-type-checking.mdc, type-annotations.mdc, code-cleanup.mdc)
  - `.cursor/rules/by-language/python/code-organization.mdc`
  - `.cursor/rules/by-language/python/code-structure.mdc`
  - `.cursor/rules/by-language/python/script-to-package.mdc`
- Example: For Python code quality tasks, check ALL files in `.cursor/rules/by-language/python/code-quality/` directory

**Tool-Specific Rules**:
- `.cursor/rules/tool/[tool]/` - Check for tool-specific rules
- Example: `.cursor/rules/tool/uv/workspace.mdc` for UV workspace tasks

**Formatting Rules**:
- `.cursor/rules/formatting/` - Check for formatting-specific rules
- Example: `.cursor/rules/formatting/terminal-output.mdc` for terminal output

**Universal Rules** (already loaded with `alwaysApply: true`):
- `.cursor/rules/code-maintenance.mdc`
- `.cursor/rules/documentation.mdc`
- `.cursor/rules/workflow.mdc` (this file)

**Project-Specific Rules**:
- `.cursor/rules/dev-boards/` - Check for dev-boards project-specific rules
- Other project directories as needed

## **ANTI-PATTERNS**

### **❌ Workflow Violations**

- ❌ **Missing Rule Discovery** - Don't start tasks without checking for relevant rule files - this is a CRITICAL PROTOCOL VIOLATION
- ❌ **Skipping Rule Discovery Steps** - Don't skip steps 1-4 of the mandatory rule discovery protocol
- ❌ **No Rule Discovery Documentation** - Don't proceed without explicitly documenting which rules were discovered and read
- ❌ **No Verification Before Code Changes** - Don't make code changes without completing rule discovery verification checkpoint
- ❌ **Reactive Rule Application** - Don't apply rules only after errors appear
- ❌ **Assuming No Rules** - Don't assume rule files don't exist or aren't relevant
- ❌ **Skipping Rule Discovery** - Don't skip the mandatory rule discovery step
- ❌ **Selective Rule Compliance** - Don't pick and choose which rules to follow
- ❌ **Proceeding Without Verification** - Don't proceed with tasks without being able to answer "What rules did I discover?" and "What rules did I read?"
- ❌ **Using Terminal Commands for File Operations** - Don't use `run_terminal_cmd` with `Add-Content`, `echo`, `cat >>`, or any terminal command for file write operations - ALWAYS use file editing tools (`search_replace`, `write`)
- ❌ **Summarizing Instead of Following Templates** - Don't write summaries when command files specify OUTPUT FORMAT templates - ALWAYS follow template structure exactly with ALL sections

## **QUALITY GATES**

- [ ] **Rule Discovery Executed First**: Rule discovery was the FIRST action taken, before any code changes
- [ ] **Rule Discovery Documented**: Explicitly stated which rule files were discovered and read in the response
- [ ] **Rule Discovery Completed**: Checked for and located all relevant rule files before starting task
- [ ] **Rule Files Listed**: Used tools (`glob_file_search`, `list_dir`) to discover and list rule files
- [ ] **Rule Files Read**: Used `read_file` to read all relevant rule files before making changes
- [ ] **Verification Checkpoint Passed**: Can answer "What rules did I discover?" and "What rules did I read?" before proceeding
- [ ] **Rules Applied Proactively**: Applied rules from the start, not after errors appear
- [ ] **No Reactive Rule Application**: Rules were not applied only after errors or warnings
- [ ] **No Code Changes Before Verification**: No code changes were made before completing rule discovery verification
- [ ] **File Editing Tools Used**: All file write operations used `search_replace` or `write` tools, NEVER terminal commands
- [ ] **Templates Followed Exactly**: When templates are specified, output matches template structure with ALL sections filled

## **SUCCESS METRICS**

After implementing proper workflow:

- ✅ **Proactive Rule Discovery** - All relevant rules checked before starting tasks
- ✅ **No Reactive Rule Application** - Rules applied from the start, not after errors
- ✅ **Comprehensive Rule Coverage** - All applicable rule files discovered and followed
- ✅ **Consistent Compliance** - All tasks follow the same rule discovery protocol

## **EXECUTION PRIORITY MATRIX**

### **CRITICAL PRIORITY (Execute immediately - BEFORE ANY OTHER ACTION)**

- **Rule Discovery (STEP 1)**: Identify task category and determine which rule directories apply
- **Rule Discovery (STEP 2)**: Use `glob_file_search` or `list_dir` to discover and list ALL relevant rule files
- **Rule Discovery (STEP 3)**: Use `read_file` to read ALL discovered rule files
- **Rule Discovery (STEP 4)**: Document which rules were discovered and read in the response
- **Verification Checkpoint**: Verify rule discovery is complete by answering "What rules did I discover?" and "What rules did I read?"
- **Read Rule Files**: Read all relevant rule files before making changes (if not already done in STEP 3)
- **Apply Rules Proactively**: Apply rules from the start, not after errors

**MANDATORY**: Steps 1-4 and verification checkpoint MUST be completed before ANY code changes, file edits, or task execution.

### **HIGH PRIORITY (Execute before proceeding)**

- Verify all relevant rule categories have been checked
- Confirm rule files have been read and understood
- Ensure rules are being applied proactively

### **MEDIUM PRIORITY (Execute during normal operation)**

- Maintain awareness of new rule files as they're added
- Update rule discovery process as category structure evolves

## **SELF-CORRECTION PROTOCOL**

### **When Rule Discovery Was Missed**

**If the AI agent realizes rule discovery was not completed before starting a task**:

1. **IMMEDIATELY STOP**: Stop all current task execution
2. **ACKNOWLEDGE OVERSIGHT**: Explicitly acknowledge that rule discovery was missed
3. **COMPLETE RULE DISCOVERY NOW**: Execute steps 1-4 of the rule discovery protocol immediately
4. **REVIEW WORK DONE**: Review any work already completed against the discovered rules
5. **CORRECT VIOLATIONS**: Fix any violations of rules that were discovered
6. **DOCUMENT CORRECTION**: Explicitly state that rule discovery was completed and any corrections made

**✅ CORRECT - Self-correction example**:

```
"I realize I did not complete rule discovery before starting this task. 
I will now:
1. Identify task category: Python code quality task
2. Discover rule files: Checking .cursor/rules/by-language/python/code-quality/ directory
3. Read rule files: Reading error-investigation.mdc, imports-and-type-checking.mdc, etc.
4. Document discovery: [list discovered rules]
5. Review work done: Checking if my changes comply with discovered rules
6. Correct violations: [fix any violations found]"
```

**❌ INCORRECT - Continuing without self-correction**:

```
# Wrong: Continuing task after realizing rule discovery was missed
# "I'll finish this task and check rules later"
# This is a CRITICAL PROTOCOL VIOLATION
```

## **FILE OPERATION TOOL REQUIREMENTS**

### **1. :: Mandatory File Editing Tool Usage**

**CRITICAL ENFORCEMENT**: The AI agent MUST use file editing tools for ALL file write operations. Terminal commands are NEVER acceptable for file modifications.

**✅ CORRECT - Use file editing tools**:

When ANY task requires modifying, creating, appending to, or writing files, the AI agent MUST:

1. **Use `search_replace` tool**: For editing existing files or appending with unique context
   - Read the file first to identify unique context
   - Use unique surrounding lines to make the match unambiguous
   - Example: `"5. Update integration tests\n\n---"` instead of just `"---"`

2. **Use `write` tool**: For creating new files or completely overwriting existing files
   - Use when the entire file content is being written
   - Use for new file creation

3. **Read-append-write pattern**: For appending to end of file when context is unclear
   - Read entire file: `content = read_file("file.md")`
   - Append new content: `content += "\n\n## New Section: ..."`
   - Write back: `write("file.md", content)`

**❌ INCORRECT - Using terminal commands for file operations**:

- ❌ **NEVER** use `run_terminal_cmd` with `Add-Content`, `echo`, `cat >>`, `printf`, or any other terminal command for file write operations
- ❌ **NEVER** use PowerShell `Add-Content` command
- ❌ **NEVER** use Unix `echo >>` or `cat >>` commands
- ❌ **NEVER** use terminal commands as a "workaround" for file editing

**MANDATORY APPLICATION**: This rule applies to ALL file operations, including:
- Phase command staging file appends
- Documentation file creation and updates
- Configuration file modifications
- Source code file edits
- Any other file write operation

**Rationale**: File editing tools provide better control, error handling, and consistency. Terminal commands bypass proper file handling mechanisms and can cause encoding issues, permission problems, and inconsistent behavior.

### **2. :: Template Format Compliance Requirements**

**CRITICAL ENFORCEMENT**: When command files, phase files, or documentation specify OUTPUT FORMAT templates, the AI agent MUST follow the exact template structure with ALL specified sections and subsections.

**✅ CORRECT - Follow templates exactly**:

When a command file specifies an OUTPUT FORMAT template:

1. **Read the template structure**: Identify ALL sections, subsections, and required fields
2. **Fill in ALL sections**: Complete every section and subsection specified in the template
3. **Maintain template structure**: Preserve the exact heading hierarchy, bullet format, and section organization
4. **Validate before completion**: Verify output matches template structure before marking phase/task complete

**Template Placeholder Interpretation**:
- `"[Complete Phase X analysis output here]"` means: "Fill in the template structure above with actual data using ALL sections"
- `"[count]"` means: "Provide the actual count value"
- `"[test_name]"` means: "Provide the actual test name"
- **NEVER** interpret placeholders as meaning "write a summary instead of following the template"

**❌ INCORRECT - Summarizing instead of following templates**:

- ❌ **NEVER** write summaries when templates specify detailed structure
- ❌ **NEVER** skip sections or subsections specified in templates
- ❌ **NEVER** interpret template placeholders as meaning "write a brief summary"
- ❌ **NEVER** assume summaries are acceptable when templates exist

**MANDATORY VALIDATION**: Before marking any phase or task complete:
- [ ] All template sections are present in output
- [ ] All template subsections are filled with actual data
- [ ] Template structure matches exactly (headings, bullets, format)
- [ ] No sections were replaced with summaries

**Rationale**: Templates ensure consistent, complete documentation. Summaries skip critical information and violate template specifications, leading to incomplete outputs.

## **NATURAL STOPS FOR RULE DISCOVERY**

**MANDATORY PAUSE POINTS**: The AI agent MUST pause and verify rule discovery at these natural stops:

1. **Before First File Edit**: Before making ANY file edit, verify rule discovery is complete
2. **Before First Code Change**: Before making ANY code change, verify rule discovery is complete
3. **Before First Tool Call**: Before calling tools that modify code, verify rule discovery is complete
4. **When User Asks "Did you check the rules?"**: This is an explicit verification request - stop and verify

**VERIFICATION REQUIRED**: At each natural stop, the AI agent MUST be able to explicitly state:
- Which rule files were discovered
- Which rule files were read
- How the rules will be applied

If this cannot be stated, rule discovery is INCOMPLETE and the task MUST NOT proceed.

## **DYNAMIC MANAGEMENT NOTE**

This document is optimized for AI agent internal processing and may be updated dynamically based on operational needs and pattern recognition. The structure prioritizes AI agent compliance and effectiveness over traditional documentation practices.
