---
alwaysApply: true
---

# Terminal Output Formatting Rules

## **CRITICAL EXECUTION DIRECTIVE**

**AI Agent Directive**: Follow terminal output formatting rules exactly for all command-line scripts and terminal interfaces.

**MANDATORY EXECUTION PROTOCOL**:

1. **NO DEVIATION**: All formatting rules must be followed exactly as written
2. **NO SKIPPING**: No steps may be skipped, abbreviated, or modified
3. **NO SELECTIVE COMPLIANCE**: All rules apply to all terminal output
4. **FAILURE TO COMPLY**: Violating these rules constitutes a critical protocol violation

## **HEADER CODE BLOCKS AND REGION INDENTING**

### **Header Functions**

#### **1. :: write_header() Function**

**✅ CORRECT - Use write_header() with region context**:

```python
with write_header("Step 1: GitHub CLI Authentication"):
    print("✓ GitHub CLI already authenticated")
    print("Additional indented content")
```

**✅ CORRECT - write_header() automatically adds blank line before header**:

```python
def write_header(title: str, width: int = 65, start_region: bool = True):
    print()  # Blank line before header
    print(f"{color_blue}┌─ {title} {tail}{color_reset}")
    if start_region:
        return start_region_context(title)
    return None
```

**❌ INCORRECT - Don't manually add blank lines before headers**:

```python
print()  # Don't add this manually
with write_header("Step 1"):
    print("Content")
```

**❌ INCORRECT - Don't use write_header() without context manager**:

```python
write_header("Step 1")  # Missing 'with' statement
print("Content")  # This won't be indented
```

#### **2. :: Region Indenting System**

**✅ CORRECT - All output within region context is automatically indented**:

```python
with write_header("Step 2: SSH Configuration"):
    print("Testing SSH connection...")  # Automatically indented with 2 spaces
    print("✓ SSH authentication working")  # Automatically indented
    subprocess.run(["command"])  # Output from subprocess also indented
```

**✅ CORRECT - Nested regions create deeper indentation**:

```python
with write_header("Step 1"):
    print("Level 1 indentation")  # 2 spaces
    with write_header("Sub-step"):
        print("Level 2 indentation")  # 4 spaces
```

**✅ CORRECT - Region context handles stdout and stderr**:

```python
class start_region_context:
    def __enter__(self):
        sys.stdout = IndentedOutput(old_stdout)
        sys.stderr = IndentedOutput(old_stderr)
        return self
```

**❌ INCORRECT - Don't manually indent content within regions**:

```python
with write_header("Step 1"):
    print("  Manually indented")  # Don't add spaces manually
```

**❌ INCORRECT - Don't mix manual indentation with region system**:

```python
with write_header("Step 1"):
    print("  Content")  # Region system handles indentation automatically
```

#### **3. :: Header Types**

**✅ CORRECT - Use write_header() for section headers**:

```python
with write_header("Step 1: GitHub CLI Authentication"):
    # Content automatically indented
```

**✅ CORRECT - Use write_header_fat() for major sections**:

```python
write_header_fat("Repository Initialization Summary")
# Note: write_header_fat() does NOT start a region (no indentation)
```

**✅ CORRECT - Use write_boxed_header() for top-level sections**:

```python
write_boxed_header("AUTOMATIC AUTHENTICATION SETUP")
print()  # Add blank line after boxed header manually
# Note: write_boxed_header() does NOT start a region
```

**❌ INCORRECT - Don't use wrong header type**:

```python
write_header_fat("Step 1")  # Use write_header() for steps
with write_boxed_header("Section"):  # Boxed headers don't support regions
    print("Content")
```

**✅ CORRECT - Single header per functional section**:

```python
# Each functional section has ONE header wrapping ALL related functionality
with write_header("Local Repository"):
    # All prompts for local repository
    local_path = prompt_text("Local path:", indent="")
    
    # All checks
    local_exists = check_local_repo_exists(local_path)
    
    # Summary display
    if local_exists:
        print()  # Blank line above warning
        print(f"{COLOR_YELLOW}⚠ Local repository exists: {local_path}{COLOR_RESET}")
    
    # Confirmation
    proceed = confirm("Proceed with initialization?", default=True, indent="")
```

**❌ INCORRECT - Multiple headers for same section**:

```python
# Wrong: Multiple headers for same functional section
with write_header("Local Repository"):
    local_path = prompt_text("Local path:", indent="")

with write_header("Local Repository"):  # Duplicate header
    print(f"Path: {local_path}")

# Correct: Single header wrapping all functionality
with write_header("Local Repository"):
    local_path = prompt_text("Local path:", indent="")
    print(f"Path: {local_path}")
```

### **Region Indenting Implementation**

#### **1. :: IndentedOutput Class**

**✅ CORRECT - IndentedOutput wraps stdout/stderr**:

```python
class IndentedOutput:
    def write(self, text):
        if _active_regions:
            indent = _region_indent * len(_active_regions)
            # Indent each line based on active region depth
```

**✅ CORRECT - Indentation depth matches region nesting**:

```python
_region_indent = "  "  # 2 spaces per region level
# 1 region = 2 spaces
# 2 regions = 4 spaces
# 3 regions = 6 spaces
```

**❌ INCORRECT - Don't modify indentation outside region system**:

```python
# Don't manually set sys.stdout without using region system
sys.stdout = IndentedOutput(sys.stdout)  # Use region context instead
```

#### **2. :: Region Context Manager**

**✅ CORRECT - Region context automatically manages streams**:

```python
class start_region_context:
    def __enter__(self):
        _active_regions.append(self.name)
        self.old_stdout = sys.stdout
        sys.stdout = IndentedOutput(self.old_stdout)
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        sys.stdout = self.old_stdout
        if _active_regions and _active_regions[-1] == self.name:
            _active_regions.pop()
```

**✅ CORRECT - Always restore original streams on exit**:

```python
def __exit__(self, exc_type, exc_val, exc_tb):
    if self.old_stdout:
        sys.stdout = self.old_stdout
    if self.old_stderr:
        sys.stderr = self.old_stderr
```

#### **3. :: Interactive Prompt Indentation**

**✅ CORRECT - prompt_toolkit Application bypasses stdout wrapper**:

```python
# prompt_toolkit Application class writes directly to TTY, bypassing IndentedOutput wrapper
# MUST manually calculate region indentation for prompt_toolkit prompts
from ..core.terminal import get_region_indent

# Calculate region indent before creating Application
region_base_indent = get_region_indent()
pointer_indent = region_base_indent  # Apply to pointer positioning

# prompt_toolkit Application will NOT automatically respect region indentation
# Manual calculation is REQUIRED
```

**✅ CORRECT - prompt_toolkit Application requires manual indentation**:

```python
with write_header("SSH Key Selection"):
    # prompt_toolkit Application bypasses IndentedOutput wrapper
    # MUST manually calculate region indentation
    from ..core.terminal import get_region_indent
    region_base_indent = get_region_indent()
    
    # Apply region indent to pointer positioning
    pointer_indent = region_base_indent
    
    # prompt_toolkit Application writes directly to TTY
    # Manual indentation calculation is REQUIRED
    selected_option = prompt_select(
        "SSH key to use (Use arrow keys):",  # Plain text, no indent, descriptive text before colon
        choices=menu_options,
        indent=region_base_indent,  # Manual indent for prompt_toolkit
        pointer=" »"
    )
```

**✅ CORRECT - Standard prompt functions use empty indent within regions**:

```python
# Standard prompt functions (text, confirm) respect IndentedOutput wrapper
# Within region contexts, use empty indent - region system handles it
with write_header("Local Repository"):
    proceed = confirm(
        "Proceed with initialization?",
        default=True,
        indent=""  # Empty - region system adds base indentation automatically
    )
```

**❌ INCORRECT - Don't pass get_region_indent() to standard prompts within regions**:

```python
# Wrong: Causes double indentation (region system + manual indent)
with write_header("Local Repository"):
    proceed = confirm(
        "Proceed?",
        indent=get_region_indent()  # Don't do this - causes double indent
    )
```

**❌ INCORRECT - Don't indent question text or pointer**:

```python
# Wrong: Indenting question text causes excessive spacing
prompt_select(
    f"{indent}SSH key to use:",  # Don't indent question text
    choices=options,
    indent=indent,  # Indent handled via indent parameter
    pointer=f"{indent} »"  # Don't manually indent pointer
)

# Wrong: Indenting choices causes double-indentation
indented_choices = [f"{indent}{choice}" for choice in choices]  # Don't do this
```

**✅ CORRECT - Dynamic indentation calculation for select prompts**:

```python
# Calculate indentation dynamically based on qmark/message positioning
region_base_indent = get_region_indent()

# Pointer aligns to qmark position (or message start if no qmark)
pointer_indent = region_base_indent
pointer_char = pointer.lstrip() if pointer.startswith(' ') else pointer

# Selected text's first character position
selected_text_start_pos = len(region_base_indent) + len(pointer_char) + 1  # pointer + space

# Unselected choices align to selected text's first character
unselected_indent = " " * selected_text_start_pos
```

**❌ INCORRECT - Don't use fixed indentation values**:

```python
# Wrong: Fixed values don't account for actual prompt positioning
unselected_indent = "  "  # Don't use fixed values
unselected_indent = "    "  # Don't use fixed values

# Correct: Calculate based on actual positions
selected_text_start_pos = len(region_base_indent) + len(pointer_char) + 1
unselected_indent = " " * selected_text_start_pos
```

**✅ CORRECT - Question text formatting**:

```python
# Question text should be plain text without indent prefix
questionary.text("SSH key name:", qmark=f"{indent}?")
questionary.confirm("Proceed?", qmark=f"{indent}?")
questionary.select("Choose option:", choices=options, qmark=f"{indent}?", pointer=" »")
```

**✅ CORRECT - Pointer and choice spacing**:

```python
# Pointer should have space before it, but no indent
# Choices should NOT be manually indented
questionary.select(
    "Choose option:",
    choices=["Option 1", "Option 2"],  # Plain choices, no indent
    qmark=f"{indent}?",  # Qmark handles base indentation
    pointer=" »"  # Space before pointer, no indent
)
# questionary automatically aligns pointer and choices based on qmark
```

**❌ INCORRECT - Manual indentation of pointer or choices**:

```python
# Wrong: Indenting pointer causes double-indentation
pointer=f"{indent} »"  # Don't indent pointer

# Wrong: Indenting choices causes incorrect spacing
indented_choices = [f"{indent}{choice}" for choice in choices]  # Don't do this
```

**✅ CORRECT - Default choice handling**:

```python
# Put desired default as FIRST choice in list to avoid funky formatting
# questionary adds special formatting when using default= parameter
questionary.select(
    "Repository visibility:",
    choices=["Public", "Private"],  # Public is first (default), no default= parameter
    style=MENU_STYLE,
    qmark=f"{indent}?",
    pointer=" »"
)

# For default that's not first, reorder choices
questionary.select(
    "Action:",
    choices=["Link to existing", "Remove and recreate"],  # Desired default first
    style=MENU_STYLE,
    qmark=f"{indent}?",
    pointer=" »"
)
```

**❌ INCORRECT - Using default parameter**:

```python
# Wrong: Using default= parameter causes funky formatting (background colors, etc.)
questionary.select(
    "Repository visibility:",
    choices=["Public", "Private"],
    default="Public",  # Don't use default= parameter
    style=MENU_STYLE,
    qmark=f"{indent}?",
    pointer=" »"
)
```

#### **4. :: Prompt Descriptive Text Formatting**

**✅ CORRECT - Descriptive text in parentheses before colon**:

```python
# Descriptive text should be in parentheses and placed BEFORE the colon
questionary.text("SSH key name (without .pub extension):", qmark=f"{indent}?")
questionary.select("SSH key to use (Use arrow keys):", choices=options, qmark=f"{indent}?", pointer=" »")
questionary.confirm("Proceed with initialization?", qmark=f"{indent}?")
```

**❌ INCORRECT - Descriptive text after colon or without parentheses**:

```python
# Wrong: Descriptive text after colon
questionary.text("SSH key name: (without .pub extension)", qmark=f"{indent}?")

# Wrong: Descriptive text without parentheses
questionary.text("SSH key name without .pub extension:", qmark=f"{indent}?")

# Wrong: Using instruction parameter instead of inline text
questionary.text("SSH key name:", instruction="(without .pub extension)", qmark=f"{indent}?")
```

**✅ CORRECT - Format pattern**:

```python
# Pattern: "Question text (descriptive text):"
# Descriptive text always in parentheses, always before colon
questionary.text("GitHub username (or organization name):", qmark=f"{indent}?")
questionary.select("SSH Key already exists: github_windows (Choose action):", choices=["Overwrite", "Use Existing"], qmark=f"{indent}?", pointer=" »")
```

#### **5. :: Confirmation Prompt Formatting**

**✅ CORRECT - Confirm prompt format specification**:

```python
# Format: {{qmark}} {{message}} [Y/n]? {{default_answer}}
# [Y/n] is in dim grey, default answer is in blue
# Prompt submits immediately on y/n keypress (no Enter required)

default_choice = "y" if default else "n"
default_text = "[Y/n]" if default else "[y/N]"

prompt_text = (
    f"{indent}{QMARK_COLOR}? {RESET_COLOR}"
    f"{QUESTION_COLOR}{question} {RESET_COLOR}"
    f"{DIM_GREY}{default_text}{RESET_COLOR}"
    f"? {ANSWER_COLOR}{default_choice}{RESET_COLOR}"
)
print(prompt_text, end='', flush=True)

# Use single-character input for immediate submission
# Unix: tty.setraw() + sys.stdin.read(1)
# Windows: msvcrt.getch()
```

**✅ CORRECT - Include default indicator in confirmation prompts**:

```python
# Confirmation prompts MUST include [Y/n] or [y/N] in dim grey
# Default answer (y/n) is shown in blue after the ?
# Capital letter in [Y/n] indicates which option is the default
confirm("Proceed with initialization?", default=True, indent="")
# Output: ? Proceed with initialization? [Y/n]? y
#         ^ qmark (pink)  ^ question (white)  ^ [Y/n] (dim grey)  ^ default (blue)

confirm("Replace existing repository/repositories?", default=False, indent="")
# Output: ? Replace existing repository/repositories? [y/N]? n
#         ^ qmark (pink)  ^ question (white)  ^ [y/N] (dim grey)  ^ default (blue)
```

**✅ CORRECT - Default indicator format**:

```python
# Pattern: "Question text [Y/n]?" where capital letter indicates default
# The [Y/n] is displayed in dim grey (DIM_GREY color)
# Default answer (y/n) is displayed in blue (ANSWER_COLOR) after the ?
confirm("Proceed with initialization?", default=True, indent="")
confirm("Continue?", default=True, indent="")
confirm("Replace existing files?", default=False, indent="")
```

**✅ CORRECT - Immediate submission on keypress**:

```python
# Prompt submits immediately when y or n is pressed (no Enter required)
# Enter key submits the default value
# Use single-character input:
# - Unix: tty.setraw() + sys.stdin.read(1)
# - Windows: msvcrt.getch()

# After reading character, restore terminal settings immediately
# Display chosen answer in blue before returning
```

**✅ CORRECT - Final display format after user input**:

```python
# When user presses 'y' or 'n', final display shows ONLY the selected answer
# Format: {{qmark}} {{message}}? {{selected_answer}}
# The [Y/n] indicator is REMOVED from final display

# Example: User presses 'y'
# Initial:   ? Proceed with initialization? [Y/n]? y
# Final:     ? Proceed with initialization? y

# Example: User presses 'n'
# Initial:   ? Proceed with initialization? [Y/n]? y
# Final:     ? Proceed with initialization? n

# When user presses Enter, keep default display (no change)
# Initial:   ? Proceed with initialization? [Y/n]? y
# Final:     ? Proceed with initialization? [Y/n]? y  (unchanged)

# CRITICAL: Initial print vs \r overwrite indentation handling
# - Initial print: Uses indent="" only, IndentedOutput wrapper adds region indent automatically
# - \r overwrite: Must manually include region indent since we're at column 0
#   IndentedOutput doesn't add indentation when overwriting existing lines

# Get region indent for final display (calculate once at function start)
region_base_indent = get_region_indent()

# Initial prompt print - IndentedOutput handles region indent automatically
prompt_text = (
    f"{indent}{QMARK_COLOR}? {RESET_COLOR}"  # indent="" within regions
    f"{QUESTION_COLOR}{question} {RESET_COLOR}"
    f"{DIM_GREY}{default_text}{RESET_COLOR}"
    f"? {ANSWER_COLOR}{default_choice}{RESET_COLOR}"
)
print(prompt_text, end='', flush=True)

# For y/n keypress: remove [Y/n] indicator, show only selected answer
# Use \r to go back to start of line, then manually include full indent
# Use \033[K to clear from cursor to end of line (removes old text)
full_indent = region_base_indent + indent

if char.lower() == 'y':
    print(f"\r{full_indent}{QMARK_COLOR}? {RESET_COLOR}{QUESTION_COLOR}{question} {RESET_COLOR}? {ANSWER_COLOR}y{RESET_COLOR}\033[K", flush=True)
    print()  # New line after prompt
    return True
elif char.lower() == 'n':
    print(f"\r{full_indent}{QMARK_COLOR}? {RESET_COLOR}{QUESTION_COLOR}{question} {RESET_COLOR}? {ANSWER_COLOR}n{RESET_COLOR}\033[K", flush=True)
    print()  # New line after prompt
    return False
```

**❌ INCORRECT - Showing both default indicator and selected answer**:

```python
# Wrong: Final display includes both [Y/n] and selected answer
if char.lower() == 'y':
    print(f"\r{indent}? {question} {DIM_GREY}[Y/n]{RESET_COLOR}? {ANSWER_COLOR}y{RESET_COLOR}", flush=True)
    # Shows: ? Question [Y/n]? y  (confusing - shows both default indicator and answer)

# Wrong: Missing indentation preservation in \r overwrite
if char.lower() == 'y':
    print(f"\r{indent}? {question}? y", flush=True)
    # Missing region indent - indentation not preserved
    # IndentedOutput doesn't add indentation when using \r overwrite

# Wrong: Not clearing line after \r overwrite
if char.lower() == 'y':
    print(f"\r{full_indent}? {question}? y", flush=True)
    # Missing \033[K - old text ([Y/n]? y) remains visible, causing corruption
```

**❌ INCORRECT - Wrong indentation handling**:

```python
# Wrong: Including region indent in initial print (double indentation)
region_base_indent = get_region_indent()
prompt_text = f"{region_base_indent}{indent}? {question}..."
# IndentedOutput adds region indent again → double indentation

# Wrong: Not including region indent in \r overwrite
if char.lower() == 'y':
    print(f"\r{indent}? {question}? y", flush=True)
    # Missing region indent - final display not indented correctly
```

**❌ INCORRECT - Missing default indicator**:

```python
# Wrong: No [Y/n] indicator
confirm("Proceed with initialization?", default=True, indent="")

# Wrong: Incorrect format - using parentheses instead of brackets
confirm("Proceed? (Y/n)", default=True, indent="")

# Wrong: Using separate text instead of inline [Y/n]
confirm("Proceed? Default: Yes", default=True, indent="")
```

**✅ CORRECT - Default indicator rules**:

- **Capital letter** in `[Y/n]` indicates the default option (e.g., `[Y/n]` means Yes is default, `[y/N]` means No is default)
- **Placement**: `[Y/n]` appears after question text, before the final `?`
- **Format**: Use square brackets `[Y/n]` or `[y/N]`, displayed in dim grey (DIM_GREY)
- **Default answer**: Shown in blue (ANSWER_COLOR) after the final `?`
- **Submission**: Immediate on y/n keypress, Enter submits default
- **Consistency**: Always include `[Y/n]` or `[y/N]` in confirmation prompts

#### **6. :: Interactive Prompt Flow**

**✅ CORRECT - Collect all user input before operations**:

```python
# Collect all required input immediately after menu selection
if selected_option == "Generate new SSH key":
    # Prompt for key name right after selection
    # Descriptive text in parentheses before colon
    new_key_name = questionary.text("SSH key name (without .pub extension):", qmark=f"{indent}?").ask()
    
    # Check for existing key and prompt for overwrite
    if key_exists:
        overwrite = questionary.select(
            "Key already exists.",
            choices=["Overwrite", "Use Existing"],
            qmark=f"{indent}?",
            pointer=" »"
        ).ask()
    
    # Store decisions for later use
    new_key_overwrite = (overwrite == "Overwrite")
    
    # Now proceed with operations using collected input
    # ... authentication and key generation ...
```

**❌ INCORRECT - Separating input collection from menu selection**:

```python
# Wrong: Collecting input later in the flow
if selected_option == "Generate new SSH key":
    # ... proceed with authentication ...
    # ... then prompt for key name much later ...
    # This creates disjointed user experience
```

## **COLORATION AND ICONS FOR MESSAGES**

### **Status Symbol Colors**

#### **1. :: Color Constants**

**✅ CORRECT - Use defined color constants**:

```python
COLOR_GREEN = "\x1B[32m"      # Green for checkmarks
COLOR_YELLOW = "\x1B[33m"     # Yellow for warnings
COLOR_RED = "\x1B[31m"        # Red for errors
COLOR_RESET = "\x1B[0m"       # Reset color
BOLD_CHECK = "✔"              # Unicode heavy/bold checkmark (U+2714)
```

**✅ CORRECT - Always reset color after colored text**:

```python
print(f"{COLOR_GREEN}{BOLD_CHECK}{COLOR_RESET} SSH: Available and usable")
```

**❌ INCORRECT - Don't use hardcoded color codes**:

```python
print("\x1B[32m✓ SSH: Available")  # Use COLOR_GREEN constant instead
```

**❌ INCORRECT - Don't forget to reset color**:

```python
print(f"{COLOR_GREEN}✓ SSH: Available")  # Missing COLOR_RESET
```

#### **2. :: Icon Usage**

**✅ CORRECT - Use BOLD_CHECK (✔) for success messages**:

```python
print(f"{COLOR_GREEN}{BOLD_CHECK}{COLOR_RESET} GitHub CLI: Installed and authenticated")
print(f"{COLOR_GREEN}{BOLD_CHECK}{COLOR_RESET} SSH: Available and usable")
print(f"{COLOR_GREEN}{BOLD_CHECK}{COLOR_RESET} Git Config: Name='{name}', Email='{email}'")
```

**✅ CORRECT - Use ⚠ for warning messages with blank line above**:

```python
# Warning messages MUST have blank line above and entire line colored yellow
print()  # Blank line above warning
print(f"{COLOR_YELLOW}⚠ GitHub CLI: Installed but not authenticated{COLOR_RESET}")
print(f"{COLOR_YELLOW}⚠ SSH: Keys exist but connection failed{COLOR_RESET}")
print(f"{COLOR_YELLOW}⚠ Git-Crypt: Installed but not configured{COLOR_RESET}")
```

**❌ INCORRECT - Don't color only the warning icon**:

```python
# Wrong: Only icon is yellow, text is default color
print(f"{COLOR_YELLOW}⚠{COLOR_RESET} GitHub CLI: Installed but not authenticated")

# Wrong: Missing blank line above warning
print(f"{COLOR_YELLOW}⚠ Warning message{COLOR_RESET}")
```

**✅ CORRECT - Use ✗ for error messages**:

```python
print(f"{COLOR_RED}✗{COLOR_RESET} GitHub CLI: Not installed")
print(f"{COLOR_RED}✗{COLOR_RESET} SSH: Not available")
print(f"{COLOR_RED}✗{COLOR_RESET} Git Config: Not configured")
```

**✅ CORRECT - Use ℹ for info messages with RGB color #0099ff**:

```python
# Info messages use RGB color #0099ff (\x1B[38;2;0;153;255m)
COLOR_INFO = "\x1B[38;2;0;153;255m"  # RGB: #0099ff
print(f"{COLOR_INFO}ℹ Cancelled{COLOR_RESET}")
print(f"{COLOR_INFO}ℹ Syncing 3 package(s): shared-cursor, shared-git, shared-python{COLOR_RESET}")
print(f"{COLOR_INFO}ℹ Direction: both{COLOR_RESET}")
```

**❌ INCORRECT - Don't use wrong icons**:

```python
print(f"{COLOR_GREEN}✓{COLOR_RESET} ...")  # Use BOLD_CHECK (✔) not regular checkmark (✓)
print(f"{COLOR_YELLOW}⚠{COLOR_RESET} ...")  # Correct warning icon
print(f"{COLOR_RED}✗{COLOR_RESET} ...")  # Correct error icon
print(f"{COLOR_CYAN}ℹ{COLOR_RESET} ...")  # Wrong: Info should use RGB #0099ff, not cyan
```

#### **3. :: Message Type Color Mapping**

**✅ CORRECT - Success messages use green with BOLD_CHECK**:

```python
# Fully working/configured items
print(f"{COLOR_GREEN}{BOLD_CHECK}{COLOR_RESET} SSH: Available and usable")
print(f"{COLOR_GREEN}{BOLD_CHECK}{COLOR_RESET} GitHub CLI: Installed and authenticated")
print(f"{COLOR_GREEN}{BOLD_CHECK}{COLOR_RESET} Git Config: Name='{name}', Email='{email}'")
```

**✅ CORRECT - Warning messages use yellow with ⚠**:

```python
# Partially configured or needs attention
print(f"{COLOR_YELLOW}⚠{COLOR_RESET} GitHub CLI: Installed but not authenticated")
print(f"{COLOR_YELLOW}⚠{COLOR_RESET} SSH: Keys exist but connection failed")
print(f"{COLOR_YELLOW}⚠{COLOR_RESET} Git-Crypt: Installed but not configured")
```

**✅ CORRECT - Error messages use red with ✗**:

```python
# Not installed or needs setup
print(f"{COLOR_RED}✗{COLOR_RESET} GitHub CLI: Not installed")
print(f"{COLOR_RED}✗{COLOR_RESET} SSH: Not available")
print(f"{COLOR_RED}✗{COLOR_RESET} Git Config: Not configured")
```

**✅ CORRECT - Info messages use RGB color #0099ff with ℹ**:

```python
# Informational messages (status updates, cancellations, etc.)
COLOR_INFO = "\x1B[38;2;0;153;255m"  # RGB: #0099ff
print(f"{COLOR_INFO}ℹ Cancelled{COLOR_RESET}")
print(f"{COLOR_INFO}ℹ Syncing 3 package(s): shared-cursor, shared-git, shared-python{COLOR_RESET}")
print(f"{COLOR_INFO}ℹ Direction: both{COLOR_RESET}")
print(f"{COLOR_INFO}ℹ Mapping: ___shared/shared-cursor/commands → .cursor/commands{COLOR_RESET}")
```

**❌ INCORRECT - Don't mix colors and icons**:

```python
print(f"{COLOR_GREEN}✗{COLOR_RESET} ...")  # Wrong: green with error icon
print(f"{COLOR_RED}{BOLD_CHECK}{COLOR_RESET} ...")  # Wrong: red with success icon
print(f"{COLOR_CYAN}ℹ{COLOR_RESET} ...")  # Wrong: cyan for info - should use RGB #0099ff
print(f"ℹ Info message{COLOR_RESET}")  # Wrong: missing color - info messages must use RGB #0099ff
```

### **Header Colors**

#### **1. :: Header Color Usage**

**✅ CORRECT - Headers use blue color**:

```python
color_blue = "\x1B[38;5;33m"
color_reset = "\x1B[0m"
print(f"{color_blue}┌─ {title} {tail}{color_reset}")
```

**✅ CORRECT - Boxed headers use cyan color**:

```python
color_cyan = "\x1B[38;5;51m"
color_reset = "\x1B[0m"
print(f"{color_cyan}┏{top_bottom}┓{color_reset}")
```

**❌ INCORRECT - Don't use wrong colors for headers**:

```python
print(f"{COLOR_GREEN}┌─ {title}{COLOR_RESET}")  # Headers should be blue/cyan, not green
```

## **FORMATTING PATTERNS**

### **1. :: Status Report Format**

**✅ CORRECT - Status reports use colored icons**:

```python
if ssh_status.get("usable", False):
    print(f"  {COLOR_GREEN}{BOLD_CHECK}{COLOR_RESET} SSH: Available and usable")
elif ssh_status.get("available", False):
    print(f"  {COLOR_YELLOW}⚠{COLOR_RESET} SSH: Available but not usable")
else:
    print(f"  {COLOR_RED}✗{COLOR_RESET} SSH: Not available")
```

**✅ CORRECT - Status lines are indented within regions**:

```python
with write_header("Connection Methods"):
    print(f"  {COLOR_GREEN}{BOLD_CHECK}{COLOR_RESET} SSH: Available and usable")
    print(f"  {COLOR_GREEN}{BOLD_CHECK}{COLOR_RESET} HTTPS: Available and usable")
```

### **2. :: Step-by-Step Format**

**✅ CORRECT - Steps use headers with region indenting**:

```python
with write_header("Step 1: GitHub CLI Authentication"):
    print("✓ GitHub CLI already authenticated")

with write_header("Step 2: SSH Configuration"):
    print("Testing SSH connection...")
    print("✓ SSH authentication working")
```

**✅ CORRECT - Blank lines separate sections**:

```python
with write_header("Step 1"):
    print("Content")
# Blank line automatically added before next header
with write_header("Step 2"):
    print("Content")
```

## **ANTI-PATTERNS**

### **❌ Manual Indentation**

- ❌ **Manual Indentation** - Don't manually add spaces when using region system
- ❌ **Mixed Indentation** - Don't mix manual indentation with region system
- ❌ **Missing Color Reset** - Always reset color after colored text
- ❌ **Wrong Icon Colors** - Don't use green with error icons or red with success icons
- ❌ **Hardcoded Colors** - Use color constants, not hardcoded ANSI codes
- ❌ **Missing Blank Lines** - Headers automatically add blank lines, don't add manually
- ❌ **Wrong Info Color** - Don't use cyan or other colors for info messages - must use RGB #0099ff (\x1B[38;2;0;153;255m)
- ❌ **Missing Info Icon** - All info messages must start with ℹ symbol

### **❌ Header Misuse**

- ❌ **Wrong Header Type** - Use write_header() for steps, not write_header_fat()
- ❌ **Missing Context Manager** - Always use 'with' statement for write_header()
- ❌ **Boxed Header Regions** - Boxed headers don't support region context

### **❌ Interactive Prompt Violations**

- ❌ **Indenting Question Text** - Don't prepend indent to question text parameters
- ❌ **Indenting Pointer** - Don't prepend indent to pointer (use " »" with space)
- ❌ **Indenting Choices** - Don't manually indent choices in questionary.select()
- ❌ **Missing Qmark Indent** - Always prepend region indent to qmark parameter for prompt_toolkit Application
- ❌ **Double Indentation in Regions** - Don't pass `get_region_indent()` to standard prompt functions within `with write_header()` blocks - use `indent=""` instead
- ❌ **Fixed Indentation Values** - Don't use fixed indentation values for select prompts - calculate dynamically based on qmark/message positioning
- ❌ **Separated Input Collection** - Don't collect user input after operations begin
- ❌ **Descriptive Text After Colon** - Don't place descriptive text after the colon (e.g., "Question: (description)")
- ❌ **Descriptive Text Without Parentheses** - Always wrap descriptive text in parentheses
- ❌ **Using Instruction Parameter** - Don't use instruction parameter for descriptive text, include it in question text before colon
- ❌ **Missing Default Indicator** - Always include [Y/n] or [y/N] in confirmation prompts to indicate default option
- ❌ **Wrong Default Indicator Format** - Use square brackets [Y/n] in dim grey, not parentheses (Y/n)
- ❌ **Final Display Shows Both Default and Answer** - When user presses y/n, final display must show ONLY the selected answer (remove [Y/n] indicator)
- ❌ **Missing Indent in Final Display** - Final display must preserve region indentation using `get_region_indent()` + `indent` parameter for \r overwrite
- ❌ **Not Clearing Line After \r Overwrite** - Always use `\033[K` after \r overwrite to clear remaining old text from the line
- ❌ **Double Indentation in Initial Print** - Don't include `region_base_indent` in initial prompt text - use `indent=""` only, let IndentedOutput handle region indent
- ❌ **Missing Region Indent in \r Overwrite** - For \r overwrite, must manually include `region_base_indent + indent` since IndentedOutput doesn't add indentation when overwriting lines
- ❌ **Warning Without Blank Line** - Always add blank line (`print()`) above warning messages
- ❌ **Warning Icon Only Colored** - Apply COLOR_YELLOW to entire warning line (icon + text), not just icon
- ❌ **Multiple Headers Per Section** - Don't create multiple headers for different parts of same functional section

## **QUALITY GATES**

- [ ] **Color Consistency**: All status messages use correct color/icon combinations
- [ ] **Indentation Consistency**: All output uses region system, no manual indentation
- [ ] **Header Formatting**: All headers use correct type and include blank lines
- [ ] **Color Reset**: All colored text is followed by COLOR_RESET
- [ ] **Icon Usage**: Success uses BOLD_CHECK (✔), warnings use ⚠, errors use ✗, info uses ℹ
- [ ] **Info Message Color**: All info messages use RGB color #0099ff (\x1B[38;2;0;153;255m) with ℹ prefix
- [ ] **Prompt Indentation**: prompt_toolkit Application prompts have manual region indent calculated, standard prompts use empty indent within regions
- [ ] **Dynamic Indentation**: Select prompts calculate indentation dynamically based on qmark/message positioning
- [ ] **Descriptive Text Format**: All prompt descriptive text is in parentheses and placed before the colon
- [ ] **Confirmation Prompt Format**: All confirmation prompts include [Y/n] or [y/N] in dim grey with default answer in blue
- [ ] **Immediate Submission**: Confirm prompts submit immediately on y/n keypress without requiring Enter
- [ ] **Final Display Format**: Final display after y/n keypress shows only selected answer (no [Y/n] indicator) and preserves indentation
- [ ] **Line Clearing After \r**: All \r overwrites use `\033[K` to clear remaining old text from the line
- [ ] **Confirm Prompt Indentation**: Initial print uses `indent=""` only (IndentedOutput handles region indent), \r overwrite uses `region_base_indent + indent` manually
- [ ] **Warning Formatting**: All warnings have blank line above and entire line colored yellow
- [ ] **Single Header Per Section**: Each functional section has only one header wrapping all related functionality
- [ ] **Input Collection**: All user input collected before operations begin

## **SUCCESS METRICS**

After implementing proper terminal output formatting:

- ✅ **Consistent Indentation** - All output properly indented using region system
- ✅ **Clear Visual Hierarchy** - Headers and sections clearly separated
- ✅ **Color-Coded Status** - Success/warning/error clearly distinguished
- ✅ **Professional Appearance** - Clean, readable terminal output
- ✅ **Maintainable Code** - Region system handles indentation automatically
